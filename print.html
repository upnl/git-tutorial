<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Git Tutorial</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="UPnL 신입회원을 위한 Git 튜토리얼">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Background and Setting</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 배경</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> 버전 관리 시스템이란?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> Git의 기초</div></li></ol></li><li class="chapter-item expanded "><a href="setting/index.html"><strong aria-hidden="true">2.</strong> 세팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting/terminal.html"><strong aria-hidden="true">2.1.</strong> 터미널 세팅</a></li><li class="chapter-item expanded "><a href="setting/install-git.html"><strong aria-hidden="true">2.2.</strong> Git 설치</a></li><li class="chapter-item expanded "><a href="setting/identity.html"><strong aria-hidden="true">2.3.</strong> 계정 아이덴티티 설정</a></li><li class="chapter-item expanded "><a href="setting/ssh.html"><strong aria-hidden="true">2.4.</strong> SSH 키 생성 및 GitHub에 등록</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">3.</strong> 사용법</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/basic.html"><strong aria-hidden="true">3.1.</strong> 기본 개념</a></li><li class="chapter-item expanded "><a href="usage/create-new-project.html"><strong aria-hidden="true">3.2.</strong> 프로젝트를 새로 생성하기</a></li><li class="chapter-item expanded "><a href="usage/commit.html"><strong aria-hidden="true">3.3.</strong> 로컬 변경 사항을 저장하기</a></li><li class="chapter-item expanded "><a href="usage/push.html"><strong aria-hidden="true">3.4.</strong> 로컬 변경 사항을 원격 저장소에 푸시하기</a></li><li class="chapter-item expanded "><a href="usage/pull.html"><strong aria-hidden="true">3.5.</strong> 원격 저장소의 변경 사항을 로컬로 가져오기</a></li><li class="chapter-item expanded "><a href="usage/merge-conflict.html"><strong aria-hidden="true">3.6.</strong> 머지 컨플릭트 해결법</a></li><li class="chapter-item expanded "><a href="usage/branch.html"><strong aria-hidden="true">3.7.</strong> 브랜치 변경하기</a></li><li class="chapter-item expanded "><a href="usage/pr.html"><strong aria-hidden="true">3.8.</strong> 풀 리퀘스트 날리기</a></li><li class="chapter-item expanded "><a href="usage/reset.html"><strong aria-hidden="true">3.9.</strong> 잘못된 변경사항을 되돌리기</a></li><li class="chapter-item expanded "><a href="usage/useful-commands.html"><strong aria-hidden="true">3.10.</strong> 알아두면 유용한 명령들</a></li></ol></li><li class="chapter-item expanded "><a href="usage/summary.html"><strong aria-hidden="true">4.</strong> 명령어 요약</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced</li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">5.</strong> 심화 과정</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/protect-branch.html"><strong aria-hidden="true">5.1.</strong> 브랜치 보호하기</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Practice</li><li class="chapter-item expanded "><a href="practice/index.html"><strong aria-hidden="true">6.</strong> 실습</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practice/clone.html"><strong aria-hidden="true">6.1.</strong> 레포지토리 복제하기</a></li><li class="chapter-item expanded "><a href="practice/modify.html"><strong aria-hidden="true">6.2.</strong> 파일 수정하기</a></li><li class="chapter-item expanded "><a href="practice/use-git.html"><strong aria-hidden="true">6.3.</strong> Git 사용하기</a></li><li class="chapter-item expanded "><a href="practice/create-pr.html"><strong aria-hidden="true">6.4.</strong> 풀 리퀘스트(PR) 날리기</a></li><li class="chapter-item expanded "><a href="practice/review-pr.html"><strong aria-hidden="true">6.5.</strong> 풀 리퀘스트(PR) 리뷰 및 승인하기</a></li><li class="chapter-item expanded "><a href="practice/end.html"><strong aria-hidden="true">6.6.</strong> 마무리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Git Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>이 문서는 Git을 처음 사용하는 신입회원이 Git에 친숙해질 수 있도록 <a href="https://upnl.org">UPnL</a>에서 제작한 튜토리얼 문서이다.
이 튜토리얼을 통해 우리는 Git이라는 버전 관리 시스템을 사용하는 방법에 대해 간략히 배울 것이다.</p>
<p>문서를 읽을 때는 화면 오른쪽의 <code>&gt;</code> 버튼을 눌러서 책을 넘기듯이 읽으면 된다. 목차는 화면 왼쪽에서 확인할 수 있다.
<a href="https://github.com/upnl/git-tutorial">GitHub</a>에서 이 문서의 소스 코드를 찾을 수 있으니 필요한 경우 참고하라.</p>
<p><a href="practice/index.html">실습</a>도 따로 준비되어 있으니 <a href="https://upnl.org">UPnL</a> 회원이라면 <a href="practice/index.html">실습</a> 문서를 따라가면서 쉽게 체험할 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="세팅"><a class="header" href="#세팅">세팅</a></h1>
<p>이 챕터에서는 Git을 사용하는데 필요한 작업에 대하여 알아본다. 우선 명령어를 입력할 수 있도록 터미널을 세팅하고 실행하는
방법에 대해 알아본다. 그리고 Git을 사용하기 위하여 설치 및 최초 설정을 진행한다. 마지막으로 GitHub을 이용하기 위한 인증 설정에 대해 설명한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="터미널-세팅"><a class="header" href="#터미널-세팅">터미널 세팅</a></h1>
<p>Git을 설치하고 필요한 명령어를 입력하기 위해서는 우선 터미널을 실행하여야 한다.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Windows 에서 제공하는 차세대 터미널인 <a href="https://github.com/microsoft/terminal">Windows Terminal</a>을 사용한다.
이는 Microsoft Store를 실행한 후, &quot;Windows Terminal&quot;을 검색하여 설치하여 사용할 수 있다.</p>
<p><img src="setting/../images/windows-terminal-0.png" alt="microsoft-store" />
<img src="setting/../images/windows-terminal-1.png" alt="windows-terminal" /></p>
<p>실행 시 기본값으로 Windows PowerShell이 열린다. 
만약 다른 것이 열린다면 아래 화살표 버튼을 누르고 Windows PowerShell을 실행한다.</p>
<p><img src="setting/../images/windows-terminal-2.png" alt="windows-powershell" /></p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>각 리눅스 배포판에서 기본으로 제공하는 터미널을 사용한다.</p>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<p>기본 터미널을 사용하여도 좋지만, <a href="https://iterm2.com">iTerm2</a> 터미널을 사용할 것을 권장한다.
다음과 같이 macOS 용 패키지 관리자인 <a href="https://brew.sh">Homebrew</a>를 사용하여 쉽게 설치할 수 있다.</p>
<pre><code class="language-console">$ brew install --cask iterm2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="설치"><a class="header" href="#설치">설치</a></h1>
<p>Git을 사용하려면 우선 설치를 하여야 한다. 이는 다음과 같이 크게 3가지 방법으로 설치할 수 있다.</p>
<ul>
<li>패키지 관리자를 사용하여 설치</li>
<li>별도의 바이너리 인스톨러를 받아 설치</li>
<li>직접 소스코드를 내려받아서 컴파일</li>
</ul>
<p>패키지 관리자를 사용하여 설치하는 것이 가장 간편하고 보편적인 방법이다. 따라서 여기에서는 이 방법을 사용하여 설명을
진행한다. 나머지 두 방법의 경우 여기서 다루지 않으니 필요한 경우 직접 알아볼 것을 추천한다.</p>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<p>윈도우는 Windows 10 버전 1709부터 공식 패키지 관리자인 <code>winget</code> 을 지원한다.</p>
<pre><code class="language-console">$ winget install -e --id Git.Git
</code></pre>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<p>각 리눅스 배포판에서 제공하는 패키지 관리자를 사용하면 된다. 다음은 그 예시이다.</p>
<h3 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h3>
<pre><code class="language-console">$ apt install git
</code></pre>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<pre><code class="language-console">$ pacman -S git
</code></pre>
<h3 id="nixnixos"><a class="header" href="#nixnixos">Nix/NixOS</a></h3>
<pre><code class="language-console">$ nix-env -i git
</code></pre>
<h3 id="alpine"><a class="header" href="#alpine">Alpine</a></h3>
<pre><code class="language-console">$ apk add git
</code></pre>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<p>macOS의 경우 기본적으로 개발 환경 구성을 위해 Command Line Tools for Xcode를 설치하여야 하는데, 이 때 Git이 자동으로
설치가 된다. 이는 다음과 같이 입력하여 설치할 수 있다. 이 과정은 macOS 버전을 업데이트 시 다시 진행할 필요가 있다.</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-설정"><a class="header" href="#git-설정">Git 설정</a></h1>
<p>터미널을 세팅한 후 Git을 설치하였으면 이제 Git 명령어를 칠 준비가 된 것이다.
하지만 실제로 Git을 사용하려면 사용자 정보나 몇 가지 환경 설정을 더 할 필요가 있다.</p>
<p>기본적으로 Git의 설정은 다음 두 파일에서 값을 읽고 수정하여 진행할 수 있다.</p>
<ul>
<li>현재 사용자에게 적용되는 설정인 <code>~/.gitconfig</code></li>
<li>현재 디렉토리에만 적용되는 설정인 <code>.git/config</code></li>
</ul>
<p>설정 파일은 <code>.git/config</code> 파일이 <code>~/.gitconfig</code> 파일보다 우선시 된다.</p>
<h2 id="git-설정하기"><a class="header" href="#git-설정하기">Git 설정하기</a></h2>
<p>앞에서 언급한 파일을 수정하여도 무방하지만, 여기서는 <code>git config</code> 명령어를 사용하여 설정을 진행한다.
터미널을 실행한 후 다음 과정을 진행한다.</p>
<h3 id="사용자-정보"><a class="header" href="#사용자-정보">사용자 정보</a></h3>
<p>Git을 설치한 후 가장 먼저 할 일은 사용자 이름과 이메일 주소를 설정하는 것이다.
다음과 같이 입력하여 사용자의 정보를 설정한다. <code>[your_name]</code> 및 <code>[you@example.com]</code> 부분에 자신의 이름과 이메일을 적으면 된다.</p>
<pre><code class="language-console">$ git config --global user.name &quot;[your_name]&quot;
$ git config --global user.email &quot;[you@example.com]&quot;
</code></pre>
<blockquote>
<p><code>--global</code> 옵션은 현재 사용자의 모든 리포지토리에 같은 아이덴티티를 적용하겠다는 의미이다.
만약 작업 중인 리포지토리에만 이 아이덴티티를 적용하고 싶다면 <code>--global</code> 대신 <code>--local</code> 옵션을 적어 실행한다.</p>
</blockquote>
<h3 id="기본-브랜치-이름"><a class="header" href="#기본-브랜치-이름">기본 브랜치 이름</a></h3>
<p>Git은 원래 기본 브랜치 이름으로 <code>master</code>라는 이름을 사용하였으나, 현재의 Git 생태계는 <code>main</code>이라는 이름을 사용하는 것을
권장한다. 따라서 다음과 같이 기본 브랜치 이름을 <code>main</code>으로 지정한다.</p>
<pre><code class="language-console">$ git config --global init.defaultBranch main
</code></pre>
<h3 id="git-pull-기본-동작-변경"><a class="header" href="#git-pull-기본-동작-변경">Git Pull 기본 동작 변경</a></h3>
<p>Git에서는 원격에서 업데이트가 된 데이터를 로컬에 반영할 때 <code>git pull</code> 명령어를 사용한다. 하지만 이 명령어의 기본 동작은
Pull의 동작을 정확히 이해하지 못한 채 사용해서는 안된다. 정석은 <code>ff-only</code> 모드를 사용하는 것이지만, 여기서는 편의상
<code>rebase</code> 모드를 사용한다.</p>
<pre><code class="language-console">$ git config --global pull.rebase true
</code></pre>
<h2 id="설정-확인"><a class="header" href="#설정-확인">설정 확인</a></h2>
<p><code>git config --list</code> 명령을 실행하면 설정한 모든 것이 보여진다. 이는 설치법이나 세팅에 따라 다음 예시보다 추가적인 항목이 더 있을 수 있다.</p>
<pre><code class="language-console">$ git config --list
user.email=[REDACTED]
user.name=[REDACTED]
init.defaultbranch=main
pull.rebase=true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssh-키-생성-및-github에-등록"><a class="header" href="#ssh-키-생성-및-github에-등록">SSH 키 생성 및 GitHub에 등록</a></h1>
<p>GitHub을 이용하려면 적절한 방법으로 GitHub과 인증 과정을 거쳐야 한다. 여기서는 SSH 키를 생성하여 GitHub에 등록하는 과정을 설명한다.
더 자세한 매뉴얼은 <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">GitHub 공식 문서</a>를 참고하라.</p>
<h2 id="ssh-키-생성"><a class="header" href="#ssh-키-생성">SSH 키 생성</a></h2>
<p>우선 할 일은 기존에 만든 SSH 키가 있는지 확인하는 작업이다.</p>
<p>터미널을 열고, <code>ls ~/.ssh</code> 를 입력한 후 <code>id_ed25519</code> 또는 <code>id_rsa</code> 가 있는지 확인한다.
만약 이러한 파일이 이미 존재한다면 이 과정을 생략하고 <a href="setting/ssh.html#github%EC%97%90-ssh-%ED%82%A4-%EB%93%B1%EB%A1%9D">다음 과정</a>을 진행해도 좋다.</p>
<p>기존 키가 없다면 다음을 수행하여 새로운 SSH 키를 생성한다.</p>
<ol>
<li>
<p>다음을 입력하여 새로운 키를 생성한다.
첫번째 줄은 Ed25519 알고리즘을, 두번째 줄은 RSA 알고리즘을 이용하는 SSH 키를 생성하는 방법이다.
두 가지 방법 중 하나만 수행하면 되며, Ed25519 방식을 권장한다.</p>
<pre><code class="language-console">$ ssh-keygen -t ed25519 -C &quot;[your_email@example.com]&quot;
$ ssh-keygen -t rsa -b 4096 -C &quot;[your_email@example.com]&quot;
</code></pre>
</li>
<li>
<p>키 생성을 시도하면 먼저 어느 위치에 저장할 것인지 물어보는데,
enter 키를 입력하면 기본값으로 설정되어 넘어간다.</p>
<pre><code class="language-console">&gt; Generating public/private algorithm key pair.
&gt; Enter file in which to save the key (/path/to/home/.ssh/algorithm):
</code></pre>
</li>
<li>
<p>다음은 비밀번호(passphrase)를 입력하는 과정이다. 원하는 비밀번호를 입력한 후 enter 키를 입력하여 설정 가능하다.
만약 비밀번호 없이 사용하고 싶은 경우 빈 칸으로 넘어가면 된다.</p>
<pre><code class="language-console">&gt; Enter passphrase (empty for no passphrase):
</code></pre>
</li>
<li>
<p>한번 더 비밀번호를 입력한다. 같은 비밀번호를 입력하되, 이전에 빈 비밀번호로 넘어갔다면 또 enter 키를 누르면 된다.</p>
<pre><code class="language-console">&gt; Enter same passphrase again:
</code></pre>
</li>
<li>
<p>이제 다음과 같이 유사한 출력이 나오면 SSH 키가 생성이 된 것이다.
생성한 키는 기본적으로 <code>~/.ssh/</code> 폴더 안에 생성되며, Ed25519 방식의 경우 <code>id_ed25519</code> 와 <code>id_ed25519.pub</code> 파일이 생성된다.
만약 RSA라면 <code>id_rsa</code>, <code>id_rsa.pub</code> 파일이 생성된다.</p>
<pre><code class="language-console">Your identification has been saved in /home/user/.ssh/id_ed25519
Your public key has been saved in /home/user/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:ST4YSAYHqCufkOFQPmAy9snp96U+AsUu5wh+BulN/Ak your_email@example.com
The key's randomart image is:
+--[ED25519 256]--+
| .oo+            |
|=o.+ .           |
|==o = . .        |
|+ o= o = .       |
|o++.o . S        |
|== E +   o       |
|+o=.X o o        |
| oo= = +         |
|  o   o..        |
+----[SHA256]-----+
</code></pre>
</li>
</ol>
<blockquote>
<p>참고로 <code>.pub</code> 확장자가 붙은 파일은 public key, 그렇지 않은 파일은 private key라고 부른다.
public key는 다른 사람들에게 공개하는 키지만, private key는 <strong>절대 다른 사람에게 공개되어서는 안 된다.</strong>
이는 패스워드를 다른 사람에게 알려주는 것과 동일한 행동이다. 절대 유출되지 않도록 하자.</p>
</blockquote>
<h2 id="github에-ssh-키-등록"><a class="header" href="#github에-ssh-키-등록">GitHub에 SSH 키 등록</a></h2>
<p>이제 앞에서 생성한 SSH 키의 public key를 GitHub에 등록하면 된다.</p>
<ol>
<li>
<p>먼저 public key를 출력한 후 내용물을 복사한다.
Windows에서는 <code>cat ~/.ssh/id_ed25519.pub | clip.exe</code>,
macOS 에서는 <code>cat ~/.ssh/id_ed25519.pub | pbcopy</code> 를 입력하여 복사 가능하다.</p>
</li>
<li>
<p><a href="https://github.com">GitHub</a>에 접속한 후 Sign in을 한다. 만약 계정이 없다면 계정을 만든 후 진행한다.</p>
</li>
<li>
<p>아래 사진처럼 오른쪽에 있는 자신의 초상화를 클릭하고 &quot;Settings&quot;를 클릭한다.
<img src="setting/../images/github-ssh-configure-0.png" alt="github-ssh-configure-0" /></p>
</li>
<li>
<p>아래 사진처럼 &quot;SSH and GPG keys&quot; 메뉴로 들어간다.
그리고 오른쪽 위에 있는 초록색 &quot;New SSH key&quot; 버튼을 클릭한다.
<img src="setting/../images/github-ssh-configure-1.png" alt="github-ssh-configure-1" /></p>
</li>
<li>
<p>아래 사진처럼 &quot;Title&quot;에는 자신이 알아볼 수 있도록 제목을 넣고, &quot;Key&quot;에는 위에서 복사한 public key의 내용물을 붙여넣는다.
Title을 채우기 어렵다면 지금 등록하는 컴퓨터의 정보를 입력하자.
<img src="setting/../images/github-ssh-configure-2.png" alt="github-ssh-configure-2" /></p>
</li>
<li>
<p>마지막으로 아래에 있는 초록색 &quot;Add SSH key&quot; 버튼을 클릭한다.</p>
</li>
</ol>
<p>위 과정을 마친 후에는 이제 생성한 SSH 키를 이용하여 GitHub 접근이 가능하다!</p>
<h2 id="ssh-테스트"><a class="header" href="#ssh-테스트">SSH 테스트</a></h2>
<p>실제로 SSH 키가 잘 등록되었는 지 확인하고 싶다면 다음을 수행한다.</p>
<ol>
<li>
<p>터미널을 열고 다음을 입력한다.</p>
<pre><code class="language-console">$ ssh -T git@github.com
</code></pre>
</li>
<li>
<p><code>ssh</code>를 통해 처음으로 GitHub에 접속한다면 다음과 같은 경고 메시지가 뜰 것이다.
<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub의 public key fingerprint</a>랑 일치하는 지 확인한 후, 맞다면 <code>yes</code>를 입력한다.</p>
<pre><code class="language-console">The authenticity of host 'github.com (20.200.245.247)' can't be established.
ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</code></pre>
</li>
<li>
<p>특별한 에러 없이 다음과 같은 메시지가 뜬다면 SSH 키 등록이 잘 완료된 것이다.</p>
<pre><code class="language-console">Hi username! You've successfully authenticated, but GitHub does not
provide shell access.
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사용법"><a class="header" href="#사용법">사용법</a></h1>
<ul>
<li>여기서부터는 Git 명령어들의 구체적인 사용법을 다룬다.
<ol>
<li><a href="usage/basic.html">기본 개념</a></li>
<li><a href="usage/create-new-project.html">프로젝트를 새로 생성하기</a></li>
<li><a href="usage/commit.html">로컬 변경 사항을 저장하기</a></li>
<li><a href="usage/push.html">로컬 변경 사항을 원격 저장소에 푸시하기</a></li>
<li><a href="usage/pull.html">원격 저장소의 변경 사항을 로컬로 가져오기</a></li>
<li><a href="usage/merge-conflict.html">머지 컨플릭트 해결법</a></li>
<li><a href="usage/branch.html">브랜치 변경하기</a></li>
<li><a href="usage/pr.html">풀 리퀘스트 날리기</a></li>
<li><a href="usage/reset.html">잘못된 변경사항을 되돌리기</a></li>
<li><a href="usage/useful-commands.html">알아두면 유용한 명령들</a></li>
</ol>
</li>
<li>각 명령어에 익숙해져 있다면, <a href="usage/summary.html">명령어 요약</a>만 보고도 쉽게 Git을 사용할 수 있을 것이다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기본-개념"><a class="header" href="#기본-개념">기본 개념</a></h1>
<ul>
<li>Git: 버전 관리 시스템의 일종.</li>
<li>로컬 작업 환경: 내 컴퓨터의 폴더에 있는 파일들을 말한다. 파일을 열어서 직접 수정할 수 있다.</li>
<li>로컬 레포지토리: 내 컴퓨터의 <code>.git</code> 폴더 안에서 Git이 관리하는 파일들을 말한다. 직접 수정할 수는 없지만 Git 명령어를 통해 조작할 수 있다.</li>
<li>원격 레포지토리: GitHub 등 원격 서버에 저장되어 관리되는 파일들을 말한다. 다른 사용자들과 공유된다.</li>
</ul>
<h2 id="그림으로-이해하기"><a class="header" href="#그림으로-이해하기">그림으로 이해하기</a></h2>
<ol>
<li><img src="usage/../images/Basic.png" alt="init" /></li>
</ol>
<hr />
<ol start="2">
<li><img src="usage/../images/BasicFetch.png" alt="fetch and pull" /></li>
</ol>
<hr />
<ol start="3">
<li><img src="usage/../images/BasicCommit.png" alt="add and commit" /></li>
</ol>
<hr />
<ol start="4">
<li><img src="usage/../images/BasicPush.png" alt="push" /></li>
</ol>
<hr />
<ol start="5">
<li><img src="usage/../images/BasicPull.png" alt="pull" /></li>
</ol>
<hr />
<ol start="6">
<li><img src="usage/../images/BasicNewCommit.png" alt="new commit and push" /></li>
</ol>
<hr />
<ol start="7">
<li><img src="usage/../images/BasicMergeConflict.png" alt="merge conflict" /></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로젝트를-새로-생성하기"><a class="header" href="#프로젝트를-새로-생성하기">프로젝트를 새로 생성하기</a></h1>
<p><img src="usage/../images/BasicFetch.png" alt="fetch and pull" /></p>
<ol>
<li>GitHub에서 새로운 원격 레포지토리 생성
<ul>
<li>GitHub 홈페이지에 Sign in 후 New 버튼을 누른다.</li>
<li><img src="usage/../images/NewRepository.PNG" alt="새 레포지토리 생성" /></li>
<li>위 사진에서 &quot;Repository name&quot;에 새 레포지토리의 이름을 정한다.
<ul>
<li>보통 소문자로만 쓰고 띄어쓰기는 <code>-</code>로 대체하는 것이 일반적이다.</li>
</ul>
</li>
<li>&quot;Description&quot;에 프로젝트 설명을 적는다. (선택사항)</li>
<li>&quot;Public&quot; 또는 &quot;Private&quot;을 선택한다.
<ul>
<li>보안이 중요한 프로젝트가 아니라면 &quot;Public&quot; 선택을 추천한다. 기능이 더 많이 지원되기 때문이다.</li>
</ul>
</li>
<li>&quot;Add a README file&quot;을 체크하면 좋다.
<ul>
<li>어차피 나중에 수정해야 하긴 하지만...</li>
</ul>
</li>
<li><strong>&quot;Add .gitignore&quot;는 프로젝트의 종류에 맞게 선택해야 한다!</strong>
<ul>
<li>가령, Unity 프로젝트라면 &quot;Unity&quot;를 선택한다.</li>
<li>이것을 선택하면 <code>.gitignore</code> 파일이 추가되고, 해당 프로젝트에서 자동으로 생기지만 레포지토리에 포함할 필요가 없는 파일들(무거운 빌드 파일 또는 임시 파일 등)을 자동으로 Git이 추적하지 않게 해준다.</li>
<li><strong>적절한 <code>.gitignore</code>가 없으면 나중에 불편할 것이다.</strong></li>
</ul>
</li>
<li>&quot;Choose a license&quot;에서는 보통 &quot;MIT License&quot;를 쓰거나, 아니면 선택하지 않기도 한다.
<ul>
<li>MIT License는 코드의 저작자만 명시한다면 코드의 복제, 수정, 상업적 이용 등을 허용하는, 매우 자유로운 라이선스이다.</li>
<li>다른 라이선스를 선택할 수도 있지만, 제한 사항 등을 꼼꼼히 읽어보고 사용하는 것이 좋다.</li>
<li>라이선스가 없으면 원 저작자에게 모든 권리가 귀속되므로, 공개(오픈 소스) 프로젝트에서는 보통 라이선스를 추가한다.</li>
<li><a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository">공식 문서</a> 참조</li>
</ul>
</li>
<li>완료되면 초록색 &quot;Create repository&quot; 버튼을 누른다.</li>
</ul>
</li>
<li>아래 사진처럼 초록색 &quot;Code&quot; 버튼을 누르고 표시되는 주소 복사
<ul>
<li><img src="usage/../images/%EC%A3%BC%EC%86%8C%EB%B3%B5%EC%82%AC.PNG" alt="주소 복사" /></li>
<li>HTTPS보다는 SSH 주소를 사용하는 것을 추천한다.</li>
<li>다만 SSH 주소를 사용하려면 사전 작업이 필요하다.</li>
<li>SSH 키를 생성하고 공개키를 GitHub에 등록하는 과정은 <a href="usage/../setting/ssh.html">SSH 키 생성 및 GitHub에 등록</a>을 참조한다.</li>
</ul>
</li>
<li><code>git init</code>
<ul>
<li>해당 폴더를 로컬 작업 환경으로 하고 로컬 레포지토리를 생성하는 명령이다.</li>
</ul>
</li>
<li><code>git remote add origin [원격 레포지토리의 SSH 또는 HTTPS 주소 붙여넣기]</code>
<ul>
<li>origin 말고 다른 이름을 사용할 수 있지만 보통은 origin 사용</li>
<li>Windows 기준으로 Git Bash에 주소를 붙여넣을 때에는 오른쪽 클릭 후 Paste 선택</li>
<li>예: <code>git remote add origin git@github.com:upnl/simple-dodge-reference.git</code></li>
</ul>
</li>
<li><code>git fetch origin</code>
<ul>
<li>처음 SSH 접근을 시도하는 경우 아래 사진과 같은 문구가 뜰 수 있다.
<ul>
<li><img src="usage/../images/SSH1.PNG" alt="SSH1" /></li>
<li>여기에서 <code>yes</code>를 입력하면 된다.</li>
<li>만약 SSH 키 설정이 되어 있지 않다면 이때 <code>Permission denied</code> 오류가 뜰 수 있다. 이 경우 <a href="usage/../setting/ssh.html">SSH 키 생성 및 GitHub에 등록</a>을 수행한 후에 다시 시도하자.</li>
</ul>
</li>
<li>SSH 키 생성 시 비밀번호를 설정한 경우, 비밀번호를 입력해야 fetch 명령이 실행된다.</li>
</ul>
</li>
<li><code>git pull origin main</code>
<ul>
<li>비밀번호를 설정한 경우, 비밀번호를 입력해야 pull 명령이 실행된다.</li>
<li>레포지토리 생성 시 자동 생성된 파일들(<code>README.md</code>, <code>.gitignore</code>, <code>LICENSE</code> 등)을 로컬로 가져와준다.</li>
</ul>
</li>
<li>로컬 작업 환경에서 파일 생성 및 수정</li>
<li><a href="usage/commit.html">로컬 변경 사항을 저장하기</a>의 명령어 입력</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="로컬-변경-사항을-저장하기"><a class="header" href="#로컬-변경-사항을-저장하기">로컬 변경 사항을 저장하기</a></h1>
<blockquote>
<p>Git은 변경사항을 자동으로 추적하지 못한다. 따라서 어느 파일이 어떻게 바뀌었는지 Git에게 알려주는 작업이 필요하다.</p>
</blockquote>
<p><img src="usage/../images/BasicCommit.png" alt="add and commit" /></p>
<ol>
<li>브랜치가 내가 작업할 브랜치인지 확인
<ul>
<li>처음 프로젝트를 시작하면 기본 브랜치가 <code>main</code>으로 설정되어 있다.</li>
<li>혼자 작업할 때에는 아무 브랜치에서 작업해도 상관 없지만, 공동으로 작업할 때에는 개인별로 하나씩의 브랜치를 파서 각자의 브랜치에서 작업한 후에 <code>main</code>으로의 풀 리퀘스트를 날리는 것이 권장된다.</li>
<li>브랜치를 변경하거나 새로 파야 하는 경우 <a href="usage/branch.html">브랜치 변경하기</a>의 명령어를 입력한다.</li>
</ul>
</li>
<li>로컬 작업 환경에서 파일 변경</li>
<li><code>git status</code>
<ul>
<li>어떤 파일이 변경되었는지 확인한다.</li>
</ul>
</li>
<li><code>git add .</code>
<ul>
<li>로컬 작업 환경에서 변경된 모든 파일을 Git이 추적하게 해준다.</li>
<li>모든 파일이 아닌 특정 파일만 Git이 추적하게 하려면, <code>.</code> 대신 해당 파일의 경로를 입력하면 된다.
<ul>
<li>예: <code>git add ./Repository/Assets/Scripts/Player/Player.cs</code></li>
</ul>
</li>
</ul>
</li>
<li><code>git commit -m &quot;[커밋 메시지]&quot;</code>
<ul>
<li>Git이 추적하고 있는 변경사항을 현재 브랜치에 커밋하여 반영한다.</li>
<li>커밋 메시지는 남들이 메시지만 봐도 무엇이 바뀌었는지 쉽게 알 수 있도록 친절하게, 요약하여 작성한다.
<ul>
<li>좋은 예: <code>git commit -m &quot;Add some sprites and fix scroll bug&quot;</code></li>
<li>나쁜 예: <code>git commit -m &quot;minor&quot;</code></li>
</ul>
</li>
<li>커밋 메시지를 한글로 작성하는 것도 가능하다.</li>
<li>한번 커밋하면 되돌리기 어렵다. 신중히 입력하자.
<ul>
<li>지난 커밋을 조작하는 방법이 있기는 하지만, 여기서 다루지는 않겠다.</li>
<li>잘못된 커밋을 <code>git push</code>하면 정말 큰일난다. 이때는 조작하기도 어렵다.</li>
</ul>
</li>
<li>계정 아이덴티티 설정이 되어 있지 않다면 커밋 시 아래 사진과 같은 문구가 뜨면서 커밋이 되지 않을 수 있다.
<ul>
<li><img src="usage/../images/Identity1.PNG" alt="Identity1" /></li>
<li>이 경우 <a href="usage/../setting/identity.html">계정 아이덴티티 설정</a>을 수행한 후에 다시 시도하자.</li>
</ul>
</li>
</ul>
</li>
<li><a href="usage/push.html">로컬 변경 사항을 원격 저장소에 푸시하기</a>의 명령어 입력</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="로컬-변경-사항을-원격-저장소에-푸시하기"><a class="header" href="#로컬-변경-사항을-원격-저장소에-푸시하기">로컬 변경 사항을 원격 저장소에 푸시하기</a></h1>
<blockquote>
<p>변경사항을 서버에 올려서 다른 사람도 볼 수 있게 하는 작업이다.</p>
</blockquote>
<p><img src="usage/../images/BasicPush.png" alt="push" /></p>
<ol>
<li><code>git push -u origin [브랜치 이름]</code>
<ul>
<li>아무 경고가 뜨지 않으면 완료된 것이다! 이때는 GitHub에 들어가 변경사항이 잘 업로드되었는지 확인한다.</li>
<li>다음과 같은 경고가 뜨면서 실패하는 경우가 있다.
<ul>
<li>메시지 예:</li>
</ul>
<pre><code>error: failed to push some refs to '[레포지토리 주소]'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>
<ul>
<li>이 경우에는 <a href="usage/pull.html">원격 저장소의 변경 사항을 로컬로 가져오기</a>의 명령어를 입력한다.</li>
</ul>
</li>
<li><code>-u</code> 옵션의 의미는 <a href="https://wotres.tistory.com/entry/git-push-u-%EC%98%B5%EC%85%98-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0">여기</a> 참조</li>
<li>잘못된 커밋이 있는 경우 절대 <code>git push</code>하지 말고 로컬에서 커밋을 조작하는 것을 추천한다.
<ul>
<li>지난 커밋을 조작하는 방법은 여기서 다루지 않는다. 검색해서 찾아보기를 바란다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="원격-저장소의-변경-사항을-로컬로-가져오기"><a class="header" href="#원격-저장소의-변경-사항을-로컬로-가져오기">원격 저장소의 변경 사항을 로컬로 가져오기</a></h1>
<p><img src="usage/../images/BasicPull.png" alt="pull" /></p>
<ol>
<li><code>git fetch origin</code>
<ul>
<li>원격 레포지토리의 변경사항이 로컬 레포지토리에 반영된다.</li>
</ul>
</li>
<li><code>git pull origin [현재 브랜치 이름]</code> 또는 간단히 <code>git pull</code>
<ul>
<li>원격 레포지토리의 변경사항이 로컬 작업 환경에 반영된다.
<ul>
<li>Git 설치 시 기본 세팅에서 &quot;rebase&quot; 옵션을 선택했다면(<a href="usage/../install/binary.html">설치 문서</a>를 그대로 따라갔다면) 자동으로 <code>git pull --rebase</code> 방식으로 동작한다.</li>
<li>만약 pull의 기본 동작이 rebase로 동작하지 않는다면 <code>git config --global pull.rebase true</code>를 입력하여 설정할 수 있다.</li>
<li>rebase와 관련한 내용은 이 문서에서는 자세히 다루지 않겠다.</li>
</ul>
</li>
<li>가끔 merge conflict가 뜨면서 이 명령이 실패하는 경우가 발생한다.
<ul>
<li>메시지 예:</li>
<li><code>CONFLICT (content): Merge conflict in [파일 이름]</code></li>
<li><code>Automatic merge failed; fix conflicts and then commit the result.</code></li>
<li>이것은 두 명 이상의 사람이 같은 시기에 특정 파일의 특정 부분을 서로 다르게 변경하여 발생하는 충돌이다.</li>
<li>이때는 <a href="usage/merge-conflict.html">머지 컨플릭트 해결법</a>을 수행한다.</li>
<li>특히 Unity를 사용할 때 같은 scene을 둘 이상의 사람들이 동시에 변경해서 머지 컨플릭트가 발생하게 되면 다른 파일들보다 해결하기 어렵기 때문에 가급적 scene 파일은 한 번에 한 사람만 수정하는 것으로 한다.</li>
</ul>
</li>
<li>현재 브랜치 이름 대신 다른 브랜치 이름을 입력해서 <code>git pull origin [다른 브랜치 이름]</code>을 수행하는 경우, <code>다른 브랜치</code>가 <code>현재 브랜치</code>에 merge된다.
<ul>
<li><code>git merge</code>에 익숙하지 않다면 이것을 하는 것을 추천하지 않는다.</li>
<li>헷갈린다면 그냥 <code>git pull</code>을 하자.</li>
</ul>
</li>
</ul>
</li>
<li>push를 하려던 중이었다면 다시 <a href="usage/commit.html">로컬 변경 사항을 저장하기</a>부터 하나씩 실행한다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="머지-컨플릭트-해결법"><a class="header" href="#머지-컨플릭트-해결법">머지 컨플릭트 해결법</a></h1>
<blockquote>
<p>두 명 이상의 사람들이 같은 파일의 같은 부분을 동시에 서로 다르게 수정하는 경우에 머지 컨플릭트가 발생한다.</p>
</blockquote>
<blockquote>
<p>머지 컨플릭트가 일어나면 Git에게 두 변경사항 중 어느 것을 반영하고 어느 것을 버려야 하는지 알려주어야 한다.</p>
</blockquote>
<p><img src="usage/../images/BasicNewCommit.png" alt="new commit and push" /></p>
<p><img src="usage/../images/BasicMergeConflict.png" alt="merge conflict" /></p>
<ul>
<li>우선 <code>git status</code>를 입력해보자.
<ul>
<li>충돌한 파일이 어떤 것들이 있는지 알려준다.</li>
</ul>
</li>
<li>충돌이 일어난 파일의 종류에 따라 해결 방법이 다르다.
<ul>
<li>텍스트 기반 파일 (코드 등)
<ol>
<li>텍스트 편집기로 해당 파일을 연다.</li>
<li>검색(Ctrl+F)을 활용하여 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> (<code>&lt;</code> 7개)를 검색한다. 검색된 모든 부분에 대해 아래 3.과 4.의 과정을 반복한다.</li>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>가 있는 줄 아래부터 <code>========</code>이 있는 줄까지는 내 현재 브랜치에서 변경한 사항이 들어있고, <code>=======</code> 아래부터 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>가 있는 줄까지는 머지하려는 브랜치(보통 다른 사람이 만든, 원격 레포지토리의 브랜치)에서 변경한 사항이 들어있다.</li>
<li>직접 보면서 적절하게 변경사항을 하나로 합치고, <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>가 있는 줄과 <code>=======</code>가 있는 줄과 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>가 있는 줄을 모두 지운 다음, 파일을 저장한다.</li>
</ol>
<ul>
<li>내가 만든 변경사항을 살릴지, 다른 사람이 만든 변경사항을 살릴지, 둘을 적절히 병합할지는 그때그때 다르다.</li>
</ul>
<ol start="5">
<li>모든 머지 컨플릭트가 해결되면 <a href="usage/commit.html">로컬 변경 사항을 저장하기</a>의 명령어를 입력한다.</li>
<li>커밋 후 <code>git push</code> 명령어를 입력하면 커밋 메시지 에디터(Git 설치 시에 설정했던, VS Code, 메모장, Vim 등의 에디터)가 열리면서 <code>Merge branch '[머지하려는 브랜치]' into [내 현재 브랜치]</code>가 뜰 때가 있다.</li>
</ol>
<ul>
<li>이것이 머지 커밋이다.</li>
<li>이때는 에디터를 닫아주면 정상적으로 머지 커밋과 <code>git push</code>가 진행된다.</li>
<li>머지 커밋 메시지를 변경하고 싶으면 변경해도 되는데, 이때는 변경 후 저장하고 에디터를 종료하면 된다.</li>
</ul>
</li>
<li>바이너리 파일 (응용 프로그램, 이미지 등)
<ul>
<li>편집기로 직접 수정하기 어려운 파일이므로, 두 변경사항 중 하나를 취사선택하는 것만 가능하다.</li>
</ul>
<ol>
<li>내 현재 브랜치의 변경사항을 살릴 때 (머지하려는 브랜치의 변경사항을 버릴 때)</li>
</ol>
<ul>
<li><code>git checkout --ours -- [충돌한 파일 경로]</code></li>
<li>(띄어쓰기에 유의)</li>
</ul>
<ol start="2">
<li>머지하려는 브랜치의 변경사항을 살릴 때 (내 현재 브랜치의 변경사항을 버릴 때)</li>
</ol>
<ul>
<li><code>git checkout --theirs -- [충돌한 파일 경로]</code></li>
<li>(띄어쓰기에 유의)</li>
<li>모든 충돌을 해결했으면 <code>git push</code> 명령어를 입력한다. 이때 커밋 메시지 에디터가 뜰 수 있는데, 에디터를 닫아주면 정상적으로 머지 커밋과 <code>git push</code>가 진행된다.</li>
</ul>
</li>
<li>Unity의 <code>.unity</code>(scene) 파일 및 <code>.prefab</code>(프리팹) 파일
<ul>
<li>가급적이면 <code>.unity</code> 파일 및 <code>.prefab</code> 파일에서 머지 컨플릭트가 발생하지 않도록 일감과 일정을 분배하는 것이 중요하다.
<ul>
<li>한 번에 한 사람만 건드리도록 하고, 동시에 여러 명이 같은 파일을 가지고 작업하지 않아야 한다.</li>
</ul>
</li>
<li>그래도 머지 컨플릭트가 발생했다면 아래의 세 가지 방법으로 해결할 수 있다.
<ol>
<li>내가 해당 scene에 새로 만든 변경사항들을 패치노트처럼 전부 기억한 다음, 원격 레포지토리의 최신 버전(내 것과 충돌한 버전)을 만들어낸 상대방의 컴퓨터에서 Unity 에디터로 해당 scene을 열어서, 내가 만들었던 변경사항들을 똑같이 수동으로 반영하고 그것으로 덮어쓰는 방법 <strong>(가장 추천하는 방법)</strong></li>
<li>바이너리 파일처럼 두 변경사항 중 하나를 취사선택하는 방법
<ul>
<li>이 경우 한 쪽의 변경사항은 전부 버려지게 된다.</li>
</ul>
</li>
<li>텍스트 기반 파일처럼  <strong>텍스트 편집기로</strong> 해당 파일을 열고 머지 컨플릭트를 수동으로 해결하는 방법 <strong>(절대 비추천)</strong>
<ul>
<li>Unity 에디터로 열지 않음에 유의!</li>
<li><code>.unity</code> 파일이 기본적으로 yaml 구조라서 가능하긴 하지만...</li>
<li>사용자는 Unity가 내부적으로 관리하는 에셋 ID를 알 방법이 없고, 이것이 꼬이면 굉장히 큰일이 난다.</li>
<li>잘못 병합하면 scene 파일 구조가 깨져서 Unity로 열리지 않게 될 수 있다!</li>
</ul>
</li>
</ol>
</li>
<li>모든 충돌을 해결했으면 <code>git push</code> 명령어를 입력한다. 이때 커밋 메시지 에디터가 뜰 수 있는데, 에디터를 닫아주면 정상적으로 머지 커밋과 <code>git push</code>가 진행된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="브랜치-변경하기"><a class="header" href="#브랜치-변경하기">브랜치 변경하기</a></h1>
<blockquote>
<p>공동으로 작업할 때에는 개인별로 하나씩의 브랜치를 파서 각자의 브랜치에서 작업한 후에 <code>main</code>으로의 풀 리퀘스트를 날리는 것이 권장된다.</p>
</blockquote>
<ol>
<li><code>git status</code>
<ul>
<li>현재 브랜치 이름을 확인한다.</li>
</ul>
</li>
<li><code>git checkout [다른 브랜치 이름]</code>
<ul>
<li>이미 만들어져 있는 다른 브랜치로 이동한다.</li>
<li>브랜치를 변경하면 로컬 작업 환경의 파일들이 새 브랜치에 맞게 통째로 바뀐다.</li>
<li>따라서 브랜치 변경 전에, 반드시 모든 파일을 저장하고 <a href="usage/commit.html">로컬 변경 사항을 저장하기</a>의 명령어를 모두 수행하여야 한다.</li>
<li>이 명령을 수행하면 브랜치가 변경되지만, 해당 브랜치가 존재하지 않고 새로 만들어야 하는 경우에는 3. 이하를 수행한다.</li>
<li><em>Git 2.25부터 <code>git checkout</code> 명령어가 <code>git switch</code> 및 <code>git restore</code>의 두 명령어로 분리되었다. 그러나 아직은 <code>git checkout</code>을 사용해도 된다.</em></li>
</ul>
</li>
<li><code>git branch</code>
<ul>
<li>로컬 레포지토리에 있는 브랜치 목록을 보여준다.</li>
</ul>
</li>
<li><code>git checkout -b [새 브랜치 이름]</code>
<ul>
<li>로컬 레포지토리에 새 브랜치를 파고 이 브랜치로 이동한다.</li>
<li>이 명령은 다음 두 명령을 순서대로 입력한 것과 동일하다.
<ul>
<li><code>git branch [새 브랜치 이름]</code></li>
<li><code>git checkout [새 브랜치 이름]</code></li>
</ul>
</li>
<li>새 브랜치로 이동할 경우 로컬 작업 환경이 그대로 유지된다.</li>
<li>새 브랜치를 만들더라도 <code>git push</code>를 하기 전까지는 로컬 레포지토리에만 이 브랜치가 존재한다.
<ul>
<li><code>git push -u origin [새 브랜치 이름]</code>을 하게 되면 원격 레포지토리에도 이 브랜치가 생성된다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="풀-리퀘스트-날리기"><a class="header" href="#풀-리퀘스트-날리기">풀 리퀘스트 날리기</a></h1>
<blockquote>
<p>내 브랜치에서 작업한 커밋들을 <code>main</code> 브랜치에 합쳐서 다른 사람들에게도 보이도록 하고 싶을 때 풀 리퀘스트(PR)을 날린다.</p>
</blockquote>
<blockquote>
<p>공동으로 작업할 때, 내 브랜치를 직접 <code>main</code> 브랜치에 <code>git merge</code>해서 <code>git push</code>하는 것은 권장되지 않는다.</p>
</blockquote>
<ol>
<li>
<p>내 브랜치에서 만든 모든 변경사항을 원격 레포지토리에 업로드</p>
<ul>
<li><a href="usage/push.html">로컬 변경 사항을 원격 저장소에 푸시하기</a>까지의 과정을 수행한 상태이면 된다.</li>
</ul>
</li>
<li>
<p><a href="https://github.com">GitHub</a>에 접속하여 작업 중인 레포지토리로 이동</p>
</li>
<li>
<p>아래 사진처럼 &quot;Pull requests&quot; 탭으로 이동</p>
<ul>
<li><img src="usage/../images/PR1.PNG" alt="풀 리퀘스트 탭" /></li>
</ul>
</li>
<li>
<p>초록색 &quot;New pull request&quot; 버튼 클릭</p>
</li>
<li>
<p>아래 사진처럼 base 브랜치를 <code>main</code>으로, compare 브랜치를 내 브랜치 이름(머지할 브랜치)으로 설정</p>
<ul>
<li><img src="usage/../images/PR2.PNG" alt="풀 리퀘스트 브랜치 설정" /></li>
</ul>
</li>
<li>
<p>위 사진처럼 &quot;Able to merge.&quot; 메시지가 뜨면, 아래에 출력되는 변경사항들을 확인한 다음 초록색 &quot;Create pull request&quot; 버튼 클릭</p>
<ul>
<li>머지 컨플릭트가 있어서 머지할 수 없다는 메시지가 뜨면, 두 가지 방법으로 해결할 수 있다.
<ol>
<li>내 로컬 작업 환경의 내 브랜치에서 <code>git pull origin main</code>을 한 다음, <a href="usage/merge-conflict.html">머지 컨플릭트 해결법</a>을 수행하고, 다시 <code>git push</code>하여 풀 리퀘스트를 날리는 방법</li>
<li>GitHub의 &quot;Resolve conflicts&quot; 기능을 활용하는 방법: <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-on-github">여기</a> 참조</li>
</ol>
</li>
</ul>
</li>
<li>
<p>아래 사진처럼 적당히 제목과 글을 작성하고 초록색 &quot;Create pull request&quot; 클릭</p>
<ul>
<li><img src="usage/../images/PR3.PNG" alt="풀 리퀘스트 작성" /></li>
<li>다른 사람이 글을 읽었을 때 어떤 변경사항이 있는지 한눈에 알기 쉽도록 적는 것이 좋다.</li>
<li>필요하다면 오른쪽에서 &quot;Reviewers&quot;나 &quot;Assignees&quot;를 설정하여 특정 사람에게 리뷰해달라고 지목할 수도 있다.</li>
</ul>
</li>
<li>
<p>풀 리퀘스트를 올렸다는 사실을 협업하는 사람들에게 알리고, 그들에게 리뷰 및 승인해달라고 한다.</p>
<ul>
<li><img src="usage/../images/PR4.PNG" alt="새로 등록된 풀 리퀘스트" /></li>
<li>풀 리퀘스트를 올린 본인이 다른 사람들의 리뷰 없이 &quot;Merge pull request&quot; 버튼을 누르는 것은 권장되지 않는다.</li>
</ul>
</li>
<li>
<p>다른 사람들은 &quot;Files changed&quot; 탭으로 들어가서 해당 풀 리퀘스트의 파일 별 변경사항을 확인하고 리뷰를 남긴 다음 승인을 해야 한다.</p>
<ul>
<li><img src="usage/../images/PR6.PNG" alt="풀 리퀘스트 리뷰" /></li>
<li>위 사진처럼 각 파일의 특정 줄(여러 줄도 드래그로 지정 가능)에 커서를 대면 파란색 &quot;+&quot; 버튼이 나타난다. 이 &quot;+&quot;를 누르면 해당 코드에 대한 리뷰를 작성할 수 있다.</li>
<li><strong>위 사진의 오른쪽 위에 있는 초록색 &quot;Review changes&quot;를 선택하면, 아래 사진처럼 세 가지 상태 중 하나로 전체적인 리뷰를 작성할 수 있다.</strong>
<ul>
<li><img src="usage/../images/PR7.PNG" alt="풀 리퀘스트 리뷰 상태" /></li>
<li>(<a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/about-pull-request-reviews">사진 출처</a>)</li>
</ul>
<ol>
<li>Comment: 명시적 승인 없이 일반적인 코멘트를 남기는 상태</li>
<li>Approval: 이 풀 리퀘스트의 변경사항을 머지해도 된다고 승인하면서 코멘트를 남기는 상태</li>
<li>Request changes: 머지 전에 꼭 고쳐야 할 사항이 있으므로 고쳐달라고 코멘트를 남기는 상태</li>
</ol>
</li>
<li>풀 리퀘스트를 올린 사람은 본인의 풀 리퀘스트를 승인할 수 없다.</li>
<li>승인을 n명 이상에게 받아야만 머지가 가능하도록 레포지토리에 설정해 둘 수 있는 기능도 존재한다.
<ul>
<li>심화 과정이지만, 관심이 있다면 <a href="usage/../advanced/protect-branch.html">브랜치 보호하기</a>를 참조하기 바란다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>다른 사람들의 승인을 받았고 이 풀 리퀘스트가 <code>main</code> 브랜치에 반영되어도 문제가 없다고 확인하면 &quot;Merge pull request&quot; 버튼을 누를 수 있다.</p>
</li>
</ol>
<ul>
<li><img src="usage/../images/PR5.PNG" alt="풀 리퀘스트 머지와 댓글" /></li>
<li>승인 과정 없이 머지를 진행하는 것은 권장되지 않는다.</li>
<li>논의할 내용이 있으면 아래에서 &quot;Comment&quot;를 작성하는 것도 가능하다.</li>
<li>머지 방식을 세 가지 중 선택할 수 있다.
<ol>
<li>Create a merge commit (기본값)</li>
<li>Squash and merge</li>
<li>Rebase and merge</li>
</ol>
</li>
<li>자세한 내용은 <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/about-merge-methods-on-github">여기(공식 문서)</a> 또는 <a href="https://nuritech.tistory.com/33">여기(한글 문서)</a>를 참조</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="잘못된-변경사항을-되돌리기"><a class="header" href="#잘못된-변경사항을-되돌리기">잘못된 변경사항을 되돌리기</a></h1>
<ul>
<li><code>git stash</code> 또는 <code>git reset --hard</code> 같은 명령들이 존재한다.
<ul>
<li>관련 설명을 찾아보고 잘 숙지한 다음 사용하도록 하자.</li>
<li>특히 <code>git reset --hard</code>는 <strong>굉장히 위험한</strong>(되돌릴 수 없는) 명령이므로 신중해야 한다.</li>
<li>이 부분은 심화 과정이므로 본 문서에서는 다루지 않는다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="알아두면-유용한-명령들"><a class="header" href="#알아두면-유용한-명령들">알아두면 유용한 명령들</a></h1>
<ul>
<li><code>git log</code>
<ul>
<li>현재 브랜치에서 지금까지 발생한 커밋을 최신의 것이 위에 놓이도록 순서대로 보여준다.</li>
<li>마지막으로 언제 어떤 작업을 했었는지, 커밋 메시지의 작성 convention이 어떻게 되는지 등을 확인할 수 있다.</li>
<li>Git Bash(Windows)에서는 <code>q</code>를 입력하여 탈출할 수 있다.</li>
<li><strong>꽤 자주 사용하는 명령이다.</strong></li>
</ul>
</li>
<li><code>git log --graph</code>
<ul>
<li>그래프 형식으로 브랜치의 흐름을 좀 더 자세하게 볼 때 유용하다.</li>
</ul>
</li>
<li><code>git log --all --decorate --oneline --graph</code>
<ul>
<li>그래프 형식으로 <strong>아주 예쁘게</strong> 브랜치의 흐름을 그려준다.</li>
</ul>
</li>
<li><code>git diff</code>
<ul>
<li><code>git add</code>를 아직 하지 않은 상황에서 수정된 파일이 있다면, 마지막 커밋과 현재 로컬 작업 환경 사이의 변경사항을 확인할 수 있다.</li>
<li>아무 변경사항이 없으면 아무 것도 출력되지 않는다.</li>
<li>패치노트 작성(변경사항 정리) 시 유용하다.</li>
</ul>
</li>
<li><code>git diff --staged</code>
<ul>
<li><code>git add</code>를 이미 한 상황에서, 마지막 커밋과 현재 Git이 추적하고 있는(<code>add</code>된) 파일들 사이의 변경사항을 확인할 수 있다.</li>
</ul>
</li>
<li><code>git diff [비교할 이전 브랜치 이름 또는 커밋 번호] [비교할 이후 브랜치 이름 또는 커밋 번호]</code>
<ul>
<li>두 브랜치(혹은 커밋) 사이에 이루어진 변경사항을 확인할 수 있다.</li>
<li>마이너스(-)가 붙은 줄은 이전 커밋(앞의 인자)에 있는 내용이고, 플러스(+)가 붙은 줄은 이후 커밋(뒤의 인자)에 있는 내용이다.</li>
<li>커밋 번호를 입력할 때에는 <code>27a1e120c15aab3ae7d415941d86a2d2a6a0d815</code>처럼 전부를 입력해도 되지만, 앞의 7자리인 <code>27a1e12</code>만 입력해도 대부분의 경우 잘 동작한다.
<ul>
<li>꼭 7자리일 필요는 없다. 더 짧게 <code>27a1</code>처럼 입력해도 다른 커밋과 중복되지 않으면(구분 가능하면) 잘 동작한다.</li>
</ul>
</li>
</ul>
</li>
<li><code>git rm [삭제할 파일 경로]</code>
<ul>
<li>특정 파일을 로컬 작업 환경 및 로컬 레포지토리에서 삭제할 수 있다.
<ul>
<li>파일이 아닌 폴더를 삭제할 때에는 <code>git rm -r [삭제할 폴더 경로]</code>를 입력한다. 이때 해당 폴더 안의 하위 폴더 및 파일들도 함께 삭제된다.</li>
</ul>
</li>
<li><strong>위험한</strong> 명령이므로 신중하게 사용해야 한다.</li>
</ul>
</li>
<li><code>git clone [원격 레포지토리의 SSH 또는 HTTPS 주소 붙여넣기]</code>
<ul>
<li>다른 사람의 public 원격 레포지토리에서 코드 전체를 내려받을 때 사용한다.</li>
<li><code>git clone</code> 명령은 다음 명령들을 모두 입력한 것과 거의 비슷한 동작을 하는 명령이다.
<ul>
<li><code>git init</code></li>
<li><code>git remote add origin [레포지토리 SSH 주소]</code></li>
<li><code>git fetch origin</code></li>
<li><code>git pull origin main</code></li>
<li><code>git branch --set-upstream-to=origin/main main</code> (원격 브랜치 <code>main</code>를 자동으로 추적하도록 하는 명령)</li>
<li>추가로 원격 레포지토리에 있는 모든 브랜치를 자동으로 추적하도록 해준다.</li>
</ul>
</li>
<li><code>git clone</code>에 익숙해지면 처음 레포지토리를 가져올 때 위의 귀찮은 명령들(<code>init</code>, <code>remote add</code>, <code>fetch</code>, <code>pull</code> 등)을 전부 입력하지 않아도 된다.</li>
<li><code>git clone</code> 관련 <a href="https://git-scm.com/docs/git-clone">공식 문서</a> 및 <a href="https://www.lainyzine.com/ko/article/git-clone-command/">한글 문서</a>를 참조하면 좋다.</li>
</ul>
</li>
<li><code>git remote -v</code>
<ul>
<li>로컬 레포지토리가 어떤 원격 레포지토리와 연결되어 있는지 확인할 수 있다.</li>
</ul>
</li>
<li><code>git remote show origin</code>
<ul>
<li>어떤 원격 브랜치가 추적되고 있는지, <code>git pull</code>과 <code>git push</code>가 로컬과 원격 사이에 어떻게 연결되어 있는지 자세히 확인할 수 있다.</li>
</ul>
</li>
<li><code>git merge [머지할 브랜치 이름]</code>
<ul>
<li>현재 브랜치에 반영되지 않은, 머지할 브랜치의 커밋들을 현재 브랜치에 병합한다.</li>
<li>머지 방식에 따라 &quot;fast-forward&quot;, &quot;recursive&quot; 등의 전략이 존재한다.
<ul>
<li>fast-forward: 현재 브랜치에는 새로운 변경사항이 없고 머지할 브랜치가 현재 브랜치보다 앞서나간(새 변경사항이 추가된) 상황에서 Git이 머지하는 전략.</li>
<li>recursive: 현재 브랜치의 특정 과거 커밋이 두 브랜치의 공통 조상이지만, 현재 브랜치와 머지할 브랜치가 해당 커밋 이후에 서로 다르게 변경된 경우
<ul>
<li>두 브랜치에서 건드린 부분(파일)이 서로 다르면 문제 없이 머지된다.</li>
<li>두 브랜치에서 건드린 부분 중 공통된 부분이 있으면 머지 컨플릭트가 난다.</li>
</ul>
</li>
</ul>
</li>
<li>자세한 내용은 <a href="https://www.geeksforgeeks.org/merge-strategies-in-git/">여기</a>를 참조하면 좋다.</li>
</ul>
</li>
<li><code>git rebase [리베이스할 브랜치 이름]</code>
<ul>
<li><code>git merge</code>와 유사하지만 조금 다른 명령</li>
<li>심화 과정이므로 본 문서에서는 자세히 설명하지 않는다.</li>
<li>자세한 내용은 <code>git rebase</code> 관련 문서들을 검색해보면 좋다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="명령어-요약"><a class="header" href="#명령어-요약">명령어 요약</a></h2>
<blockquote>
<p>각 명령어가 어떤 역할을 하는지 숙지했다면, 아래 명령어들을 적절히 사용하여 대부분의 Git 관련 작업을 수행할 수 있다.</p>
</blockquote>
<ul>
<li><code>git init</code></li>
<li><code>git remote add origin [원격 레포지토리의 SSH 또는 HTTPS 주소]</code></li>
<li><code>git fetch origin</code></li>
<li><code>git pull origin main</code></li>
<li><code>git checkout -b [새로 만들 내 브랜치 이름]</code></li>
<li>로컬 작업 환경의 파일 수정</li>
<li><code>git status</code></li>
<li><code>git log</code></li>
<li><code>git add .</code></li>
<li><code>git commit -m &quot;[커밋 메시지]&quot;</code></li>
<li><code>git push -u origin [현재 브랜치 이름]</code></li>
<li>GitHub에 들어가서, 내 브랜치(compare)에서 <code>main</code> 브랜치(base)로의 풀 리퀘스트(PR) 생성</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="심화-과정"><a class="header" href="#심화-과정">심화 과정</a></h1>
<ul>
<li>여기서는 알면 좋지만 자주 사용하지는 않는 Git 또는 GitHub의 기능들을 소개한다.</li>
<li>추후에 내용이 더 추가될 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="브랜치-보호하기"><a class="header" href="#브랜치-보호하기">브랜치 보호하기</a></h1>
<ul>
<li>해당 레포지토리에 대해 Admin 권한을 가진 사람들은 특정 브랜치가 잘못된 명령으로부터 보호받을 수 있도록 설정할 수 있다.</li>
<li>특정 브랜치를 보호받는 브랜치로 설정할 때, 여러 가지 보호 옵션을 설정할 수 있다.
<ul>
<li>그 중에서도 직접 해당 브랜치에 푸시할 수 없고 PR을 통해서만 변경 사항을 반영할 수 있도록 설정하는 방법을 소개한다.</li>
</ul>
</li>
<li>공식 문서는 <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#require-pull-request-reviews-before-merging">여기</a>를 참조</li>
</ul>
<hr />
<ol>
<li>GitHub에서 본인이 Admin 권한을 가진 레포지토리의 Settings로 들어간다.</li>
</ol>
<ul>
<li>본인이 생성한 레포지토리이면 본인이 Admin 권한을 가진다.</li>
<li>그렇지 않다면 Admin 권한을 가진 사람에게 [Settings] - [Collaborators and teams] - [Manage access] - [Add people]을 통해 자신을 추가하고 Admin 권한을 부여해달라고 부탁해야 한다.</li>
<li>Admin 권한이 없는 사람은 브랜치 보호하기 설정을 할 수 없다.</li>
</ul>
<ol start="2">
<li>아래 사진처럼 [Settings] - [Branches] - [Branch protection rules]에서 &quot;Add rule&quot; 버튼을 누른다.</li>
</ol>
<ul>
<li><img src="advanced/../images/ProtectBranch1.PNG" alt="protect-branch" /></li>
</ul>
<ol start="3">
<li>아래 사진의 (1)처럼 보호할 브랜치 이름을 &quot;Branch name pattern&quot;에 적는다.</li>
</ol>
<ul>
<li>보통 주 브랜치인 <code>main</code>을 보호하면 좋다.</li>
</ul>
<ol start="4">
<li>보호할 브랜치로 직접 푸시하는 것을 막고 풀 리퀘스트(PR)를 통해서만 변경 사항을 반영하게 하려면 아래 사진의 (2) &quot;Require a pull request before merging&quot;에 체크한다.</li>
<li>PR 과정에서 다른 사람들의 승인이 필요하도록 강제하려면 아래 사진의 (3) &quot;Require approvals&quot;에 체크한다.</li>
<li>특정 인원 이상의 사람들이 승인해야 PR의 머지가 가능하도록 강제하려면 아래 사진의 (4) &quot;Required number of approvals before merging&quot;을 눌러 인원을 변경할 수 있다.</li>
</ol>
<ul>
<li><img src="advanced/../images/ProtectBranch2.PNG" alt="require-PR" /></li>
</ul>
<ol start="7">
<li>그 외에도 많은 브랜치 보호 기능들이 있으니 직접 살펴보고 설정하면 된다.</li>
</ol>
<ul>
<li>&quot;Require linear history&quot;: 머지 커밋이 쌓이지 않게 하는 기능</li>
<li>&quot;Include administrators&quot;: Admin 권한이 있는 사람들에게도 동일한 브랜치 보호 규칙 적용 (여기에 체크하지 않으면 Admin들은 보호되는 브랜치에도 직접 푸시할 수 있다.)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="실습"><a class="header" href="#실습">실습</a></h1>
<blockquote>
<p>2022-06-18</p>
</blockquote>
<ul>
<li>백문이 불여일견이니 모든 과정을 간단하게 체험해보자.</li>
<li><a href="practice/../install/index.html">설치</a> 및 <a href="practice/../setting/index.html">초기 세팅</a>은 완료된 상태라고 가정하고 시작한다.</li>
</ul>
<h2 id="팀-프로젝트에-합류하는-시나리오"><a class="header" href="#팀-프로젝트에-합류하는-시나리오">팀 프로젝트에 합류하는 시나리오</a></h2>
<ul>
<li>프로젝트를 발주하게 되면, 누군가는 새 레포지토리를 파게 된다.
<ul>
<li>이때는 <a href="practice/../usage/create-new-project.html">프로젝트를 새로 생성하기</a>를 보고 따라하면 된다.</li>
</ul>
</li>
<li>그러나 오늘 다룰 실습에서는 누군가가 이미 레포지토리를 만들어 둔 상태에서 여러분이 이 프로젝트에 합류하는 시나리오를 다루고자 한다.
<ul>
<li>그러려면 우선 해당 레포지토리에 대한 접근 및 수정 권한을 여러분이 얻어야 한다.</li>
<li>다행히도 여러분은 모두 UPnL 그룹에 가입되어 있고, UPnL에서는 아래 사진과 같이 그룹 구성원 모두에게 수정 권한을 주기 때문에 큰 문제가 없다.
<ul>
<li><img src="practice/../images/Privileges.png" alt="수정 권한" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>참고: 만약 다른 사람이 만든 레포지토리의 수정 권한을 얻고자 한다면, 해당 레포지토리의 admin 권한을 가진 사람에게 초대를 받아야 한다.
<ul>
<li>방법은 아래 사진처럼 [Settings] - [Collaborators and teams] - [Manage access]의 초록색 &quot;Add people&quot; 버튼을 눌러서 초대할 사람의 GitHub 아이디를 입력하는 것이다.</li>
<li><img src="practice/../images/AddPeople.PNG" alt="초대" /></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>여러분이 합류하게 될 프로젝트의 레포지토리 주소는 다음과 같다.
<ul>
<li><a href="https://github.com/upnl/git-practice">https://github.com/upnl/git-practice</a></li>
<li>이 레포지토리는 <strong>private 레포지토리</strong>이므로, UPnL 그룹에 소속된 GitHub 아이디로 접속하지 않으면 &quot;404 Page not found&quot;가 보일 것이다.</li>
<li>자신의 GitHub 아이디로 Sign in 하기를 바란다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레포지토리-복제하기"><a class="header" href="#레포지토리-복제하기">레포지토리 복제하기</a></h1>
<ul>
<li>Git bash(Windows) 또는 터미널을 켠다.
<ul>
<li><a href="practice/../setting/terminal.html">터미널 세팅</a> 참조</li>
</ul>
</li>
<li><code>cd</code> 명령을 활용하여 레포지토리의 루트 폴더를 둘 상위 폴더로 이동한다.</li>
<li><a href="https://github.com/upnl/git-practice">https://github.com/upnl/git-practice</a> 에서 초록색 &quot;Code&quot; 버튼을 누르고 SSH 탭에 나타나는 주소를 복사한다.</li>
<li><code>git clone [레포지토리 SSH 주소]</code>를 입력한다.
<ul>
<li><code>[레포지토리 SSH 주소]</code> 부분에 복사했던 주소를 붙여넣는다.</li>
<li>비밀번호를 입력하라고 나오면 자신의 비밀번호를 입력한다.</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>참고: <code>git clone</code> 명령은 다음 명령들을 모두 입력한 것과 거의 비슷한 동작을 하는 명령이다.
<ul>
<li><code>git init</code></li>
<li><code>git remote add origin [레포지토리 SSH 주소]</code></li>
<li><code>git fetch origin</code></li>
<li><code>git pull origin main</code></li>
<li><code>git branch --set-upstream-to=origin/main main</code> (원격 브랜치 <code>main</code>를 자동으로 추적하도록 하는 명령)</li>
<li>추가로 원격 레포지토리에 있는 모든 브랜치를 자동으로 추적하도록 해준다.</li>
</ul>
</li>
<li><code>git clone</code> 관련 공식 문서는 <a href="https://git-scm.com/docs/git-clone">여기</a>를 참조</li>
</ul>
</blockquote>
<ul>
<li><code>git clone</code> 과정이 완료되면 <code>git-practice</code>라는 폴더가 생성될 것이다.
<ul>
<li><code>cd git-practice</code>를 입력해 폴더 안으로 이동한다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="파일-수정하기"><a class="header" href="#파일-수정하기">파일 수정하기</a></h1>
<ul>
<li><code>git-practice</code> 폴더 안에는 <code>.gitignore</code>와 <code>README.md</code> 파일이 있다.
<ul>
<li>터미널에서는 <code>ls</code> 명령을 입력하여 확인할 수 있다.</li>
</ul>
</li>
<li><code>.gitignore</code> 파일은 오늘은 건드리지 않을 것이다.
<ul>
<li>이것은 Unity 프로젝트 전용으로 생성한 파일로, Unity에서 만들어내는, 그러나 프로젝트에 포함되지 않아도 되는 불필요한 파일들을 Git이 무시하게 해준다.</li>
</ul>
</li>
<li><code>README.md</code> 파일을 열어보자.
<ul>
<li><strong>Visual Studio Code</strong>로 열면 좋고, 아니면 메모장 등의 텍스트 에디터로 열어도 된다.</li>
</ul>
</li>
<li><code>* (여기에 본인 이름을 적어주세요!)</code> 부분을 고쳐보자.
<ul>
<li>예: <code>* 안단태</code></li>
</ul>
</li>
<li>수정한 파일을 저장하자!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-사용하기"><a class="header" href="#git-사용하기">Git 사용하기</a></h1>
<ul>
<li>Git bash 또는 터미널에서 <code>git checkout -b [자신의 영어 닉네임]</code>을 입력한다.
<ul>
<li>예) <code>git checkout -b salt26</code></li>
<li>이렇게 하면 협업하는 프로젝트에서 <strong>자신만의 공간(브랜치)을 만들고 그곳으로 이동하여 작업</strong>할 수 있다.</li>
<li>이걸 하지 않으면 <code>main</code> 브랜치에서 작업하게 되는데, 이는 협업 상황에서는 바람직하지 않다.</li>
</ul>
</li>
<li><code>git status</code>를 입력해보자.
<ul>
<li>현재 브랜치 이름이 <code>[자신의 영어 닉네임]</code>인지 확인하자.
<ul>
<li>브랜치가 <code>main</code>에 있다면 <code>git checkout -b [자신의 영어 닉네임]</code> 과정을 꼭 수행해 주기를 바란다.</li>
</ul>
</li>
<li>빨간색 글씨로 <code>README.md</code>가 표시되는 것을 확인할 수 있다.</li>
<li>이런 파일은 아직 Git이 추적하지 않는(unstaged/untracked) 파일이다.</li>
</ul>
</li>
<li><code>git diff</code>를 입력해보자.
<ul>
<li>구체적으로 어떤 파일에서 어떤 내용이 어떻게 바뀌었는지 확인할 수 있다.</li>
<li>초록색 글씨는 추가된 내용, 빨간색 글씨는 삭제된 내용이다.</li>
<li>위, 아래 화살표로 이동하고, <code>q</code>를 눌러 나올 수 있다.</li>
</ul>
</li>
<li>방금 수정한 파일을 <strong>Git이 추적하게</strong> 하려면 <code>git add .</code>을 입력한다.</li>
<li>다시 <code>git status</code>를 입력해보자.
<ul>
<li>이제 초록색 글씨로 <code>README.md</code>가 표시된다.</li>
<li>이런 파일은 Git이 추적하고 있지만(staged) 아직 커밋(commit)되지 않은 파일이다.</li>
</ul>
</li>
<li><code>git commit -m &quot;Update README.md&quot;</code>를 입력해서 <a href="practice/../usage/commit.html">로컬 레포지토리에 커밋</a>한다.
<ul>
<li>커밋 메시지는 여기서는 <code>&quot;Update README.md&quot;</code>로 할 것이지만, 다른 사람이 보더라도 쉽게 변경 사항을 이해할 수 있도록 적으면 좋다.</li>
</ul>
</li>
<li>다시 <code>git status</code>를 입력해보자.
<ul>
<li>이제 초록색 글씨도, 빨간색 글씨도 보이지 않지만, 푸시(push)를 하라는 알림이 표시된다.</li>
</ul>
</li>
<li><code>git push -u origin [현재 브랜치 이름]</code>을 입력해서 <a href="practice/../usage/push.html">원격 레포지토리에 푸시</a>한다.
<ul>
<li>비밀번호를 입력하라고 나오면 자신의 비밀번호를 입력한다.</li>
<li><code>[현재 브랜치 이름]</code>을 잘못 입력한 경우에는 보통 아무 일도 일어나지 않으니 다시 시도하면 된다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="풀-리퀘스트pr-날리기"><a class="header" href="#풀-리퀘스트pr-날리기">풀 리퀘스트(PR) 날리기</a></h1>
<blockquote>
<ul>
<li>참고: 사용법에 <a href="practice/../usage/pr.html">풀 리퀘스트 날리기</a> 문서가 있다.</li>
</ul>
</blockquote>
<ul>
<li>GitHub에 접속해서 &quot;Pull requests&quot; 탭으로 이동한다.</li>
<li>초록색 &quot;New pull request&quot; 버튼을 누른다.</li>
<li>base를 <code>main</code>으로 두고, compare를 <code>[자신의 브랜치 이름]</code>으로 둔다.
<ul>
<li>compare 브랜치의 변경 사항을 base 브랜치에 합치고 싶다는 풀 리퀘스트를 날리는 과정이다.</li>
<li>초록색으로 &quot;Able to merge&quot; 표시가 뜨면 PR을 날렸을 때 큰 문제 없이 자신의 변경 사항을 합칠 수 있다는 뜻이다.</li>
<li>Merge conflict가 있다는 표시가 뜨더라도 PR을 날릴 수는 있다.</li>
</ul>
</li>
<li>풀 리퀘스트의 제목과 내용을 적당히 작성하고 초록색 &quot;Create pull request&quot; 버튼을 누른다.
<ul>
<li>제목과 내용은 변경 사항을 다른 사람들이 쉽게 이해할 수 있도록 작성하면 좋다.</li>
</ul>
</li>
<li>풀 리퀘스트가 생성되면 다른 팀원들에게 연락해서 리뷰 및 머지를 부탁한다.
<ul>
<li>자신이 만든 풀 리퀘스트를 타인의 리뷰 및 승인 없이 본인이 머지하는 것은 바람직하지 않다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="풀-리퀘스트pr-리뷰-및-승인하기"><a class="header" href="#풀-리퀘스트pr-리뷰-및-승인하기">풀 리퀘스트(PR) 리뷰 및 승인하기</a></h1>
<ul>
<li>다른 팀원이 PR을 올렸다면, 여러분에게는 코드를 리뷰하고 승인할 의무가 생긴다.</li>
<li>GitHub에 접속해서 &quot;Pull requests&quot; 탭으로 이동한다.</li>
<li>&quot;Open pull requests&quot; 중 자신이 올리지 않은 것 하나를 선택한다.</li>
<li>올라온 코멘트가 있는지, 머지가 자연스럽게 가능한지 확인한다.
<ul>
<li>초록색으로 &quot;This branch has no conflicts with the base branch&quot;가 표시되면 큰 문제 없이 머지가 가능한 것이다.</li>
<li>회색으로 &quot;This branch has conflicts that must be resolved&quot;가 표시되면 &quot;Resolve conflicts&quot; 버튼을 눌러보자. <strong>머지 컨플릭트를 해결</strong>해야 하기 때문이다.</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>이번 실습에서는, 가장 먼저 PR을 날린 사람의 것은 자연스럽게 머지가 되겠지만 그 뒤에 PR을 날린 사람들은 모두 머지 컨플릭트가 나도록 의도하였다.</li>
</ul>
</blockquote>
<ul>
<li>&quot;Files changed&quot; 탭으로 이동한다.
<ul>
<li>변경 사항들을 쭉 보면서 각 파일의 어떤 부분이 어떻게 바뀌었는지 확인한다.</li>
<li>이 변경 사항들이 <code>main</code> 브랜치에 합쳐졌을 때 문제가 발생할 여지가 있는지 확인한다.</li>
</ul>
</li>
</ul>
<h2 id="머지-컨플릭트-해결하기"><a class="header" href="#머지-컨플릭트-해결하기">머지 컨플릭트 해결하기</a></h2>
<blockquote>
<ul>
<li>참고: 사용법에 <a href="practice/../usage/merge-conflict.html">머지 컨플릭트 해결법</a> 문서가 있다.
<ul>
<li>위 링크의 문서는 <code>git pull</code>을 하다가 로컬 환경에서 머지 컨플릭트를 해결해야 하는 경우를 다룬다.</li>
</ul>
</li>
<li>이번 실습에서는 GitHub 내에서 해결하는 방법을 다뤄보겠다. 공식 문서는 <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-on-github">여기</a>를 참조하라.</li>
</ul>
</blockquote>
<ul>
<li>머지 컨플릭트가 난 상황에서는 해당 파일의 해당 위치에 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 표시가 생겨 있다.
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>와 <code>=======</code> 사이에는 PR을 날린 사람의 이름이 적혀 있을 것이고, <code>=======</code>와 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 사이에는 이미 <code>main</code> 브랜치에 반영된 다른 사람들의 이름이 적혀 있을 것이다.</li>
<li>이 상황에서는 둘 다 남아있도록 합쳐야 하므로, <strong>그냥 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 표시가 있는 줄들만 지워서</strong> 자연스럽게 합쳐주자.</li>
</ul>
</li>
<li>파일 편집이 끝나면 &quot;Mark as resolved&quot; 버튼을 눌러 머지 컨플릭트를 해결했다고 표시하자.</li>
<li>모든 머지 컨플릭트를 해결했으면 &quot;Commit merge&quot;를 눌러 머지 컨플릭트 해결을 반영한 새 커밋을 만들 수 있다.
<ul>
<li>새 커밋을 어디에 올릴지 묻는 창이 뜬다.</li>
<li>현재 브랜치(PR을 날린 사람의 개인 브랜치)에 바로 커밋하는 것(첫 번째 선택지)을 선택하자.</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>참고: 만약 현재 브랜치가 <code>main</code>이라면 바로 커밋하지 말고 새 브랜치를 만들어서 PR을 새로 날리는 것(두 번째 선택지)을 권장한다.</li>
</ul>
</blockquote>
<h2 id="리뷰하기"><a class="header" href="#리뷰하기">리뷰하기</a></h2>
<ul>
<li>풀 리퀘스트의 &quot;Files changed&quot; 탭으로 이동한다.</li>
<li>여기서는 딱히 리뷰할 내용은 없기 때문에, 오른쪽 상단의 초록색 &quot;Review changes&quot; 버튼을 누른다.</li>
</ul>
<blockquote>
<ul>
<li>참고: 코드의 각 줄마다(여러 줄도 드래그로 가능) 커서를 올리면 파란색 &quot;+&quot; 버튼이 나타난다. 이 &quot;+&quot;를 누르면 해당 코드에 대한 리뷰를 작성할 수 있다.
<ul>
<li>여기서 리뷰를 작성하고 &quot;Start a review&quot;를 누르더라도 아래 과정(&quot;Submit review&quot;)을 거치기 전까지는 다른 사람들에게 리뷰가 보이지 않는다.</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>해당 PR에 대한 전반적인 코멘트를 작성하고, &quot;Approve&quot;에 체크한 후에, 초록색 &quot;Submit review&quot;를 누른다.
<ul>
<li>머지 컨플릭트를 위에서 해결한 상황이기 때문에 PR을 승인해도 된다.</li>
<li><em>코멘트에는 가급적이면 긍정적인 말을 적어줍시다!</em></li>
</ul>
</li>
<li>다시 &quot;Conversation&quot; 탭으로 돌아온다.</li>
<li>초록색 &quot;Merge pull request&quot; 버튼을 누른다.
<ul>
<li>본인의 PR이 아닌 경우에!</li>
</ul>
</li>
<li>머지가 완료되면 &quot;Delete branch&quot; 버튼을 눌러서 해당 개인 브랜치를 제거할 수도 있다.
<ul>
<li>단, 브랜치 삭제는 브랜치 주인의 허락을 받고 하는 것이 좋다.</li>
<li>브랜치를 삭제하면 레포지토리를 깔끔하게 유지하는 데 도움이 된다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="마무리"><a class="header" href="#마무리">마무리</a></h1>
<ul>
<li>이제 &quot;Code&quot; 탭을 누르고 <code>main</code> 브랜치로 이동한다.</li>
<li>참석자 명단에 자신 및 다른 사람들의 이름이 포함되어 있음을 확인한다.
<ul>
<li>코드가 있는 프로젝트라면 자신의 변경 사항이 잘 반영되어 있음을 확인한다.</li>
</ul>
</li>
<li>끝!</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
