# Git 명령어 안내
## 목차
- [Git 명령어 안내](#git-명령어-안내)
  - [목차](#목차)
  - [기본 개념](#기본-개념)
  - [설치](#설치)
    - [Windows](#windows)
  - [사용법](#사용법)
    - [Windows](#windows-1)
    - [Linux/Mac](#linuxmac)
  - [명령어](#명령어)
    - [1. 프로젝트를 새로 생성할 때](#1-프로젝트를-새로-생성할-때)
    - [2. 로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때](#2-로컬-작업-환경의-변경사항을-로컬-레포지토리에-반영할-때)
    - [3. 로컬 레포지토리의 변경사항을 원격 레포지토리에 업로드할 때](#3-로컬-레포지토리의-변경사항을-원격-레포지토리에-업로드할-때)
    - [4. 원격 레포지토리의 변경사항을 로컬 레포지토리 및 작업 환경에 다운로드할 때](#4-원격-레포지토리의-변경사항을-로컬-레포지토리-및-작업-환경에-다운로드할-때)
    - [5. 머지 컨플릭트 해결법](#5-머지-컨플릭트-해결법)
    - [6. 브랜치를 변경할 때](#6-브랜치를-변경할-때)
    - [7. 풀 리퀘스트 날리는 법](#7-풀-리퀘스트-날리는-법)
    - [8. 잘못된 변경사항을 되돌리는 법](#8-잘못된-변경사항을-되돌리는-법)
    - [9. 알아두면 유용한 명령들](#9-알아두면-유용한-명령들)
  - [작성자](#작성자)

---

## 기본 개념
* Git: 버전 관리 시스템의 일종.
* 로컬 작업 환경: 내 컴퓨터의 폴더에 있는 파일들을 말한다. 파일을 열어서 직접 수정할 수 있다.
* 로컬 레포지토리: 내 컴퓨터의 `.git` 폴더 안에서 Git이 관리하는 파일들을 말한다. 직접 수정할 수는 없지만 Git 명령어를 통해 조작할 수 있다.
* 원격 레포지토리: GitHub 등 원격 서버에 저장되어 관리되는 파일들을 말한다. 다른 사용자들과 공유된다.

## 설치
* https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%84%A4%EC%B9%98

### Windows
* [여기](http://git-scm.com/download/win)에서 "Click here to download" 링크 클릭
* 다운로드한 파일 실행
  * 아래는 버전 2.35.1.2-64-bit 기준으로 작성하였다.
* ![설치1](Screenshots/%EC%84%A4%EC%B9%981.PNG)
  * "Only show new options"를 체크하지 **않고** "Next" 클릭
* ![설치2](Screenshots/%EC%84%A4%EC%B9%982.PNG)
  * 위 사진처럼 체크하고 "Next" 클릭
    * Windows Explorer integration 체크
      * Git Bash Here 체크
      * Git GUI Here 체크 **해제** (체크해도 괜찮음)
    * Git LFS (Large File Support) 체크
    * Associate .git* configuration files with the default text editor 체크
    * Associate .sh files to be run with Bash 체크
  * 다른 옵션도 읽어보고 필요하면 체크해도 괜찮다.
* ![설치3](Screenshots/%EC%84%A4%EC%B9%983.PNG)
  * Visual Studio Code가 설치되어 있는 경우 위 사진처럼 Code를 사용할 수 있고, 아니면 메모장(Notepad)이나 본인이 편한 에디터로 설정하면 된다.
  * 나중에 커밋 메시지를 작성하거나 두 브랜치를 머지하려고 할 때 여기서 설정했던 에디터가 열린다.
* ![설치4](Screenshots/%EC%84%A4%EC%B9%984.PNG)
  * 위 사진처럼 두 번째 항목에 체크하고 초기 브랜치 이름이 `main`으로 적혀 있는지 확인하고 "Next" 클릭
  * 예전에는 새 레포지토리의 주 브랜치 이름이 `master`였지만, 최근에는 `main`으로 갈아타고 있는 추세이다.
  * 이미 Git을 사용하고 있었다면, 이 옵션을 변경하여 새로 설치해도 기존 레포지토리에는 영향을 주지 않는다.
* ![설치5](Screenshots/%EC%84%A4%EC%B9%985.PNG)
  * 중간에 "(Recommended)"된 두 번째 항목에 체크하고 "Next" 클릭
* ![설치6](Screenshots/%EC%84%A4%EC%B9%986.PNG)
  * 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
* ![설치7](Screenshots/%EC%84%A4%EC%B9%987.PNG)
  * 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
* ![설치8](Screenshots/%EC%84%A4%EC%B9%988.PNG)
  * Windows 사용자라면 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
  * Linux(Unix) 사용자라면 두 번째 항목에 체크하고 "Next" 클릭
* ![설치9](Screenshots/%EC%84%A4%EC%B9%989.PNG)
  * 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
  * 그러나 명령 프롬프트(cmd)를 너무나 사랑한다면 두 번째 항목에 체크하고 "Next" 클릭해도 된다.
* ![설치10](Screenshots/%EC%84%A4%EC%B9%9810.PNG)
  * 머지 커밋을 남겨도 상관없는 경우 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
    * 사람에 따라 머지 커밋이 기록으로 남는 게 지저분하다고 생각할 수 있지만, 크게 문제가 되지는 않는다.
  * 머지 커밋을 남기고 싶지 않고 rebase 명령을 잘 이해하고 있다면 두 번째 항목에 체크하고 "Next" 클릭해도 된다.
* ![설치11](Screenshots/%EC%84%A4%EC%B9%9811.PNG)
  * 위 사진처럼 첫 번째 항목에 체크하고 "Next" 클릭
* ![설치12](Screenshots/%EC%84%A4%EC%B9%9812.PNG)
  * 위 사진처럼 첫 번째 항목에만 체크하고 "Next" 클릭
* ![설치13](Screenshots/%EC%84%A4%EC%B9%9813.PNG)
  * 위 사진처럼 아무 항목도 체크하지 **않고** "Install" 클릭
  * 각 항목을 읽어보고 써보고 싶다는 생각이 들면 체크해도 괜찮다.


## 사용법
### Windows
* ![Git bash here](Screenshots/GitBashHere.PNG)
* 프로젝트의 루트 폴더에서(또는 새 폴더를 생성하고 그 안에 들어가서) 파일 탐색기의 빈 공간을 마우스 우클릭 - Git Bash Here 실행
* 후술할 Git 명령어를 상황에 맞게 입력

### Linux/Mac
* 셸 또는 터미널에서 `cd` 명령을 통해 프로젝트의 루트 폴더로 이동
* 후술할 Git 명령어를 상황에 맞게 입력

## 명령어
### 1. 프로젝트를 새로 생성할 때
1. GitHub에서 새로운 원격 레포지토리 생성
   * GitHub 홈페이지에 Sign in 후 New 버튼을 누르고 레포지토리 이름을 정해서 생성하면 된다.
2. 아래 사진처럼 초록색 "Code" 버튼을 누르고 표시되는 주소 복사
   * ![주소 복사](Screenshots/%EC%A3%BC%EC%86%8C%EB%B3%B5%EC%82%AC.PNG)
   * HTTPS보다는 SSH가 보안이 좋아 더 선호된다.
   * 다만 SSH를 사용하려면 다소 복잡한 사전 작업이 필요하다.
   * SSH 키를 생성하고 공개키를 GitHub에 등록하는 과정은 [여기](https://www.lainyzine.com/ko/article/creating-ssh-key-for-github/)를 참조
3. `git init`
   * 해당 폴더를 로컬 작업 환경으로 하고 로컬 레포지토리를 생성하는 명령이다.
4. `git remote add origin [원격 레포지토리의 SSH 또는 HTTPS 주소 붙여넣기]`
   * origin 말고 다른 이름을 사용할 수 있지만 보통은 origin 사용
   * Windows 기준으로 Git Bash에 주소를 붙여넣을 때에는 오른쪽 클릭 후 Paste 선택
   * 예: `git remote add origin git@github.com:upnl/simple-dodge-reference.git`
5. `git fetch origin`
6. 로컬 작업 환경에서 파일 생성 및 수정
7. [로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때](#2-로컬-작업-환경의-변경사항을-로컬-레포지토리에-반영할-때)의 명령어 입력

### 2. 로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때
> Git은 변경사항을 자동으로 추적하지 못한다. 따라서 어느 파일이 어떻게 바뀌었는지 Git에게 알려주는 작업이 필요하다.
1. 브랜치가 내가 작업할 브랜치인지 확인
   * 처음 프로젝트를 시작하면 기본 브랜치가 `main`으로 설정되어 있다.
   * 혼자 작업할 때에는 아무 브랜치에서 작업해도 상관 없지만, 공동으로 작업할 때에는 개인별로 하나씩의 브랜치를 파서 각자의 브랜치에서 작업한 후에 `main`으로의 풀 리퀘스트를 날리는 것이 권장된다.
   * 브랜치를 변경하거나 새로 파야 하는 경우 [브랜치를 변경할 때](#6-브랜치를-변경할-때)의 명령어를 입력한다.
2. 로컬 작업 환경에서 파일 변경
3. `git status`
   * 어떤 파일이 변경되었는지 확인한다.
4. `git add .`
   * 로컬 작업 환경에서 변경된 모든 파일을 Git이 추적하게 해준다.
   * 모든 파일이 아닌 특정 파일만 Git이 추적하게 하려면, `.` 대신 해당 파일의 경로를 입력하면 된다.
     * 예: `git add ./Repository/Assets/Scripts/Player/Player.cs`
5. `git commit -m "[커밋 메시지]"`
   * Git이 추적하고 있는 변경사항을 현재 브랜치에 커밋하여 반영한다.
   * 커밋 메시지는 남들이 메시지만 봐도 무엇이 바뀌었는지 쉽게 알 수 있도록 친절하게, 요약하여 작성한다.
     * 좋은 예: `git commit -m "Add some sprites and fix scroll bug"`
     * 나쁜 예: `git commit -m "minor"`
   * 한번 커밋하면 되돌리기 어렵다. 신중히 입력하자.
6. [로컬 레포지토리의 변경사항을 원격 레포지토리에 업로드할 때](#3-로컬-레포지토리의-변경사항을-원격-레포지토리에-업로드할-때)의 명령어 입력

### 3. 로컬 레포지토리의 변경사항을 원격 레포지토리에 업로드할 때
> 변경사항을 서버에 올려서 다른 사람도 볼 수 있게 하는 작업이다.
1. `git push -u origin [브랜치 이름]`
   * 아무 경고가 뜨지 않으면 완료된 것이다! 이때는 GitHub에 들어가 변경사항이 잘 업로드되었는지 확인한다.
   * 다음과 같은 경고가 뜨면서 실패하는 경우가 있다.
     * 메시지 예:
       * `error: failed to push some refs to '[레포지토리 주소]'`
       * `hint: Updates were rejected because the remote contains work that you do`
       * `hint: not have locally. This is usually caused by another repository pushing`
       * `hint: to the same ref. You may want to first integrate the remote changes`
       * `hint: (e.g., 'git pull ...') before pushing again.`
       * `hint: See the 'Note about fast-forwards' in 'git push --help' for details.`
     * 이 경우에는 [원격 레포지토리의 변경사항을 로컬 레포지토리 및 작업 환경에 다운로드할 때](#4-원격-레포지토리의-변경사항을-로컬-레포지토리-및-작업-환경에-다운로드할-때)의 명령어를 입력한다.
   * `-u` 옵션의 의미는 [여기](https://wotres.tistory.com/entry/git-push-u-%EC%98%B5%EC%85%98-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0) 참조

### 4. 원격 레포지토리의 변경사항을 로컬 레포지토리 및 작업 환경에 다운로드할 때
1. `git fetch origin`
   * 원격 레포지토리의 변경사항이 로컬 레포지토리에 반영된다.
2. `git pull origin [현재 브랜치 이름]`
   * 원격 레포지토리의 변경사항이 로컬 작업 환경에 반영된다.
   * 가끔 merge conflict가 뜨면서 이 명령이 실패하는 경우가 발생한다.
      * 메시지 예:
       * `CONFLICT (content): Merge conflict in [파일 이름]`
       * `Automatic merge failed; fix conflicts and then commit the result.`
     * 이것은 두 명 이상의 사람이 같은 시기에 특정 파일의 특정 부분을 서로 다르게 변경하여 발생하는 충돌이다.
     * 이때는 [머지 컨플릭트 해결법](#5-머지-컨플릭트-해결법)을 수행한다.
     * 특히 Unity를 사용할 때 같은 scene을 둘 이상의 사람들이 동시에 변경해서 머지 컨플릭트가 발생하게 되면 다른 파일들보다 해결하기 어렵기 때문에 가급적 scene 파일은 한 번에 한 사람만 수정하는 것으로 한다.
   * 현재 브랜치 이름 대신 다른 브랜치 이름을 입력해서 `git pull origin [다른 브랜치 이름]`을 수행하는 경우, `다른 브랜치`가 `현재 브랜치`에 merge된다.
     * `git merge`에 익숙하지 않다면 이것을 하는 것을 추천하지 않는다.
3. push를 하려던 중이었다면 다시 [로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때](#2-로컬-작업-환경의-변경사항을-로컬-레포지토리에-반영할-때)부터 하나씩 실행한다.

### 5. 머지 컨플릭트 해결법
> 두 명 이상의 사람들이 같은 파일의 같은 부분을 동시에 서로 다르게 수정하는 경우에 머지 컨플릭트가 발생한다.

> 머지 컨플릭트가 일어나면 Git에게 두 변경사항 중 어느 것을 반영하고 어느 것을 버려야 하는지 알려주어야 한다.

* 우선 `git status`를 입력해보자.
  * 충돌한 파일이 어떤 것들이 있는지 알려준다.
* 충돌이 일어난 파일의 종류에 따라 해결 방법이 다르다.
  * 텍스트 기반 파일 (코드 등)
    1. 텍스트 편집기로 해당 파일을 연다.
    2. 검색(Ctrl+F)을 활용하여 `<<<<<<<` (`<` 7개)를 검색한다. 검색된 모든 부분에 대해 아래 3.과 4.의 과정을 반복한다.
    3. `<<<<<<<`가 있는 줄 아래부터 `========`이 있는 줄까지는 내 현재 브랜치에서 변경한 사항이 들어있고, `=======` 아래부터 `>>>>>>>`가 있는 줄까지는 머지하려는 브랜치(보통 다른 사람이 만든, 원격 레포지토리의 브랜치)에서 변경한 사항이 들어있다.
    4. 직접 보면서 적절하게 변경사항을 하나로 합치고, `<<<<<<<`가 있는 줄과 `=======`가 있는 줄과 `>>>>>>>`가 있는 줄을 모두 지운 다음, 파일을 저장한다.
      * 내가 만든 변경사항을 살릴지, 다른 사람이 만든 변경사항을 살릴지, 둘을 적절히 병합할지는 그때그때 다르다.
    5. 모든 머지 컨플릭트가 해결되면 [로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때](#2-로컬-작업-환경의-변경사항을-로컬-레포지토리에-반영할-때)의 명령어를 입력한다.
    6. 커밋 후 `git push` 명령어를 입력하면 커밋 메시지 에디터(Git 설치 시에 설정했던, VS Code, 메모장, Vim 등의 에디터)가 열리면서 `Merge branch '[머지하려는 브랜치]' into [내 현재 브랜치]`가 뜰 때가 있다.
      * 이것이 머지 커밋이다.
      * 이때는 에디터를 닫아주면 정상적으로 머지 커밋과 `git push`가 진행된다.
      * 머지 커밋 메시지를 변경하고 싶으면 변경해도 되는데, 이때는 변경 후 저장하고 에디터를 종료하면 된다.
  * 바이너리 파일 (응용 프로그램, 이미지 등)
    * 편집기로 직접 수정하기 어려운 파일이므로, 두 변경사항 중 하나를 취사선택하는 것만 가능하다.
    1. 내 현재 브랜치의 변경사항을 살릴 때 (머지하려는 브랜치의 변경사항을 버릴 때)
      * `git checkout --ours -- [충돌한 파일 경로]`
      * (띄어쓰기에 유의)
    2. 머지하려는 브랜치의 변경사항을 살릴 때 (내 현재 브랜치의 변경사항을 버릴 때)
      * `git checkout --theirs -- [충돌한 파일 경로]`
      * (띄어쓰기에 유의)
    * 모든 충돌을 해결했으면 `git push` 명령어를 입력한다. 이때 커밋 메시지 에디터가 뜰 수 있는데, 에디터를 닫아주면 정상적으로 머지 커밋과 `git push`가 진행된다.
  * Unity의 `.unity`(scene) 파일
    * 가급적이면 `.unity` 파일에서 머지 컨플릭트가 발생하지 않도록 일감과 일정을 분배하는 것이 중요하다.
    * 그래도 머지 컨플릭트가 발생했다면 아래의 세 가지 방법으로 해결할 수 있다.
      1. 텍스트 기반 파일처럼  **텍스트 편집기로** 해당 파일을 열고 머지 컨플릭트를 수동으로 해결하는 방법
         * Unity 에디터로 열지 않음에 유의!
         * `.unity` 파일이 기본적으로 yaml 구조라서 가능하다.
         * 굉장히 난이도가 높은 방법이다.
         * 잘못 병합하면 scene 파일 구조가 깨져서 Unity로 열리지 않게 될 수 있다!
      2. 바이너리 파일처럼 두 변경사항 중 하나를 취사선택하는 방법
         * 이 경우 한 쪽의 변경사항은 전부 버려지게 된다.
      3. 내가 해당 scene에 새로 만든 변경사항들을 패치노트처럼 전부 기억한 다음, 원격 레포지토리의 최신 버전(내 것과 충돌한 버전)을 만들어낸 상대방의 컴퓨터에서 Unity 에디터로 해당 scene을 열어서, 내가 만들었던 변경사항들을 똑같이 수동으로 반영하고 그것으로 덮어쓰는 방법
    * 모든 충돌을 해결했으면 `git push` 명령어를 입력한다. 이때 커밋 메시지 에디터가 뜰 수 있는데, 에디터를 닫아주면 정상적으로 머지 커밋과 `git push`가 진행된다.

### 6. 브랜치를 변경할 때
> 공동으로 작업할 때에는 개인별로 하나씩의 브랜치를 파서 각자의 브랜치에서 작업한 후에 `main`으로의 풀 리퀘스트를 날리는 것이 권장된다.

1. `git status`
   * 현재 브랜치 이름을 확인한다.
2. `git checkout [다른 브랜치 이름]`
   * 이미 만들어져 있는 다른 브랜치로 이동한다.
   * 브랜치를 변경하면 로컬 작업 환경의 파일들이 새 브랜치에 맞게 통째로 바뀐다.
   * 따라서 브랜치 변경 전에, 반드시 모든 파일을 저장하고 [로컬 작업 환경의 변경사항을 로컬 레포지토리에 반영할 때](#2-로컬-작업-환경의-변경사항을-로컬-레포지토리에-반영할-때)의 명령어를 모두 수행하여야 한다.
   * 이 명령을 수행하면 브랜치가 변경되지만, 해당 브랜치가 존재하지 않고 새로 만들어야 하는 경우에는 3. 이하를 수행한다.
3. `git branch`
   * 로컬 레포지토리에 있는 브랜치 목록을 보여준다.
4. `git checkout -b [새 브랜치 이름]`
   * 로컬 레포지토리에 새 브랜치를 파고 이 브랜치로 이동한다.
   * 이 명령은 다음 두 명령을 순서대로 입력한 것과 동일하다.
     * `git branch [새 브랜치 이름]`
     * `git checkout [새 브랜치 이름]`
   * 새 브랜치로 이동할 경우 로컬 작업 환경이 그대로 유지된다.
   * 새 브랜치를 만들더라도 `git push`를 하기 전까지는 로컬 레포지토리에만 이 브랜치가 존재한다.
     * `git push -u origin [새 브랜치 이름]`을 하게 되면 원격 레포지토리에도 이 브랜치가 생성된다.

### 7. 풀 리퀘스트 날리는 법
> 내 브랜치에서 작업한 커밋들을 `main` 브랜치에 합쳐서 다른 사람들에게도 보이도록 하고 싶을 때 풀 리퀘스트(PR)을 날린다.

> 공동으로 작업할 때, 내 브랜치를 직접 `main` 브랜치에 `git merge`해서 `git push`하는 것은 권장되지 않는다.

1. 내 브랜치에서 만든 모든 변경사항을 원격 레포지토리에 업로드
   * [로컬 레포지토리의 변경사항을 원격 레포지토리에 업로드할 때](#3-로컬-레포지토리의-변경사항을-원격-레포지토리에-업로드할-때)까지의 과정을 수행한 상태이면 된다.
2. GitHub에 접속하여 작업 중인 레포지토리로 이동
3. 아래 사진처럼 "Pull requests" 탭으로 이동
   * ![풀 리퀘스트 탭](Screenshots/PR1.PNG)
4. 초록색 "New pull request" 버튼 클릭
5. 아래 사진처럼 base 브랜치를 `main`으로, compare 브랜치를 내 브랜치 이름(머지할 브랜치)으로 설정
   * ![풀 리퀘스트 브랜치 설정](Screenshots/PR2.PNG)
6. 위 사진처럼 "Able to merge." 메시지가 뜨면, 아래에 출력되는 변경사항들을 확인한 다음 초록색 "Create pull request" 버튼 클릭
   * 머지 컨플릭트가 있어서 머지할 수 없다는 메시지가 뜨면, 두 가지 방법으로 해결할 수 있다.
     1. 내 로컬 작업 환경의 내 브랜치에서 `git pull origin main`을 한 다음, [머지 컨플릭트 해결법](#5-머지-컨플릭트-해결법)을 수행하고, 다시 `git push`하여 풀 리퀘스트를 날리는 방법
     2. GitHub의 "Resolve conflicts" 기능을 활용하는 방법: [여기](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-on-github) 참조
7. 아래 사진처럼 적당히 제목과 글을 작성하고 초록색 "Create pull request" 클릭
   * ![풀 리퀘스트 작성](Screenshots/PR3.PNG)
   * 다른 사람이 글을 읽었을 때 어떤 변경사항이 있는지 한눈에 알기 쉽도록 적는 것이 좋다.
   * 필요하다면 오른쪽에서 "Reviewers"나 "Assignees"를 설정하여 특정 사람에게 리뷰해달라고 지목할 수도 있다.
8. 풀 리퀘스트를 올렸다는 사실을 협업하는 사람들에게 알리고, 그들에게 리뷰해서 머지해달라고 하기
   * ![새로 등록된 풀 리퀘스트](Screenshots/PR4.PNG)
   * 풀 리퀘스트를 올린 본인이 "Merge pull request" 버튼을 누르는 것은 권장되지 않는다.
9. 다른 사람들은 해당 풀 리퀘스트의 변경사항을 확인하고, 이것이 `main` 브랜치에 반영되어도 문제가 없다고 확인하면 "Merge pull request" 버튼을 누를 수 있다.
   * ![풀 리퀘스트 머지와 댓글](Screenshots/PR5.PNG)
   * 논의할 내용이 있으면 아래에서 "Comment"를 작성하는 것도 가능하다.

### 8. 잘못된 변경사항을 되돌리는 법
* `git stash` 또는 `git reset --hard` 같은 명령들이 존재한다.
  * 관련 설명을 찾아보고 잘 숙지한 다음 사용하도록 하자.
  * 특히 `git reset --hard`는 **굉장히 위험한**(되돌릴 수 없는) 명령이므로 신중해야 한다.
  * 이 부분은 심화 과정이므로 본 문서에서는 다루지 않는다.

### 9. 알아두면 유용한 명령들
* `git log`
  * 현재 브랜치에서 지금까지 발생한 커밋을 최신의 것이 위에 놓이도록 순서대로 보여준다.
  * 마지막으로 언제 어떤 작업을 했었는지, 커밋 메시지의 작성 convention이 어떻게 되는지 등을 확인할 수 있다.
  * Git Bash(Windows)에서는 `q`를 입력하여 탈출할 수 있다.
  * **꽤 자주 사용하는 명령이다.**
* `git log --graph`
  * 그래프 형식으로 브랜치의 흐름을 좀 더 자세하게 볼 때 유용하다.
* `git diff`
  * `git add`를 아직 하지 않은 상황에서 수정된 파일이 있다면, 마지막 커밋과 현재 로컬 작업 환경 사이의 변경사항을 확인할 수 있다.
  * 아무 변경사항이 없으면 아무 것도 출력되지 않는다.
  * 패치노트 작성(변경사항 정리) 시 유용하다.
* `git diff --staged`
  * `git add`를 이미 한 상황에서, 마지막 커밋과 현재 Git이 추적하고 있는(`add`된) 파일들 사이의 변경사항을 확인할 수 있다.
* `git diff [비교할 이전 브랜치 이름 또는 커밋 번호] [비교할 이후 브랜치 이름 또는 커밋 번호]`
  * 두 브랜치(혹은 커밋) 사이에 이루어진 변경사항을 확인할 수 있다.
  * 마이너스(-)가 붙은 줄은 이전 커밋(앞의 인자)에 있는 내용이고, 플러스(+)가 붙은 줄은 이후 커밋(뒤의 인자)에 있는 내용이다.
  * 커밋 번호를 입력할 때에는 `27a1e120c15aab3ae7d415941d86a2d2a6a0d815`처럼 전부를 입력해도 되지만, 앞의 7자리인 `27a1e12`만 입력해도 대부분의 경우 잘 동작한다.
* `git rm [삭제할 파일 경로]`
  * 특정 파일을 로컬 작업 환경 및 로컬 레포지토리에서 삭제할 수 있다.
    * 파일이 아닌 폴더를 삭제할 때에는 `git rm -r [삭제할 폴더 경로]`를 입력한다. 이때 해당 폴더 안의 하위 폴더 및 파일들도 함께 삭제된다.
  * **위험한** 명령이므로 신중하게 사용해야 한다.
* `git clone [원격 레포지토리의 SSH 또는 HTTPS 주소 붙여넣기]`
  * 다른 사람의 public 원격 레포지토리에서 코드 전체를 내려받을 때 사용한다.
  * 이 명령을 사용하면 해당 레포지토리에 변경을 가하고 `git push`하는 것은 불가능할 수도 있다.
    * 수정 작업에 참여할 레포지토리라면, 수정 권한을 얻은 후에 `git remote add origin [원격 레포지토리의 SSH 또는 HTTPS 주소 붙여넣기]`으로 내려받아야 한다.
    * [여기](https://www.lainyzine.com/ko/article/git-clone-command/)를 참조하면 좋다.
* `git remote -v`
  * 로컬 레포지토리가 어떤 원격 레포지토리와 연결되어 있는지 확인할 수 있다.
* `git merge [머지할 브랜치 이름]`
  * 현재 브랜치에 반영되지 않은, 머지할 브랜치의 커밋들을 현재 브랜치에 병합한다.
  * 머지 방식에 따라 "fast-forward", "recursive" 등의 전략이 존재한다.
    * fast-forward: 현재 브랜치에는 새로운 변경사항이 없고 머지할 브랜치가 현재 브랜치보다 앞서나간(새 변경사항이 추가된) 상황에서 Git이 머지하는 전략.
    * recursive: 현재 브랜치의 특정 과거 커밋이 두 브랜치의 공통 조상이지만, 현재 브랜치와 머지할 브랜치가 해당 커밋 이후에 서로 다르게 변경된 경우
      * 두 브랜치에서 건드린 부분(파일)이 서로 다르면 문제 없이 머지된다.
      * 두 브랜치에서 건드린 부분 중 공통된 부분이 있으면 머지 컨플릭트가 난다.
   * 자세한 내용은 [여기](https://www.geeksforgeeks.org/merge-strategies-in-git/)를 참조하면 좋다.
* `git rebase [리베이스할 브랜치 이름]`
  * `git merge`와 유사하지만 조금 다른 명령
  * 심화 과정이므로 본 문서에서는 자세히 설명하지 않는다.
  * 자세한 내용은 [여기](https://nuritech.tistory.com/33)를 참조하거나 다른 문서를 검색해보면 좋다.

---

## 작성자
* 안단태 (https://github.com/salt26)